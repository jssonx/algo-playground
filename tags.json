[
    {
        "id": 222,
        "fid": 222,
        "name": "Count Complete Tree Nodes",
        "slug": "count-complete-tree-nodes",
        "link": "https://leetcode.com/problems/count-complete-tree-nodes/description/",
        "percent": 60.16674185277608,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "binary-search",
            "tree"
        ],
        "totalAC": "526.8K",
        "totalSubmit": "875.6K",
        "likes": 7069,
        "dislikes": 395,
        "desc": "<p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>\n\n<p>According to <strong><a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>\n\n<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type=\"code\">O(n)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The tree is guaranteed to be <strong>complete</strong>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countNodes(self, root: Optional[TreeNode]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint countNodes(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int CountNodes(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countNodes = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef count_nodes(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func countNodes(_ root: TreeNode?) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc countNodes(root *TreeNode) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def countNodes(root: TreeNode): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun countNodes(root: TreeNode?): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn count_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function countNodes($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction countNodes(root: TreeNode | null): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (count-nodes root)\n  (-> (or/c tree-node? #f) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec count_nodes(Root :: #tree_node{} | null) -> integer().\ncount_nodes(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec count_nodes(root :: TreeNode.t | nil) :: integer\n  def count_nodes(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int countNodes(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,3,4,5,6]",
        "testable": true,
        "templateMeta": {
            "name": "countNodes",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 142,
        "fid": 142,
        "name": "Linked List Cycle II",
        "slug": "linked-list-cycle-ii",
        "link": "https://leetcode.com/problems/linked-list-cycle-ii/description/",
        "percent": 47.127138275351484,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "linked-list",
            "two-pointers"
        ],
        "totalAC": "925.9K",
        "totalSubmit": "2M",
        "likes": 10064,
        "dislikes": 734,
        "desc": "<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>\n\n<p><strong>Do not modify</strong> the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 145px; width: 450px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 105px; width: 201px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 65px; width: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode *detectCycle(struct ListNode *head) {\n    \n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DetectCycle(ListNode head) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val)\n#         @val = val\n#         @next = nil\n#     end\n# end\n\n# @param {ListNode} head\n# @return {ListNode}\ndef detectCycle(head)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.next = nil\n *     }\n * }\n */\n\nclass Solution {\n    func detectCycle(_ head: ListNode?) -> ListNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode(var _x: Int = 0) {\n *   var next: ListNode = null\n *   var x: Int = _x\n * }\n */\n\nobject Solution {\n    def detectCycle(head: ListNode): ListNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\n\nclass Solution {\n    fun detectCycle(head: ListNode?): ListNode? {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) { $this->val = $val; }\n * }\n */\n\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function detectCycle($head) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    \n};"
            }
        ],
        "testcase": "[3,2,0,-4]\n1",
        "testable": true,
        "templateMeta": {
            "name": "detectCycle",
            "params": [
                {
                    "name": "head",
                    "type": "ListNode"
                },
                {
                    "name": "pos",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "ListNode"
            },
            "languages": [
                "cpp",
                "java",
                "python",
                "c",
                "csharp",
                "javascript",
                "golang",
                "python3",
                "swift",
                "kotlin",
                "php",
                "ruby",
                "scala",
                "typescript"
            ],
            "manual": true
        }
    },
    {
        "id": 28,
        "fid": 28,
        "name": "Find the Index of the First Occurrence in a String",
        "slug": "find-the-index-of-the-first-occurrence-in-a-string",
        "link": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/",
        "percent": 37.953480551871195,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "apple",
            "facebook",
            "microsoft",
            "pocketgems"
        ],
        "tags": [
            "two-pointers",
            "string"
        ],
        "totalAC": "1.5M",
        "totalSubmit": "4M",
        "likes": 1423,
        "dislikes": 102,
        "desc": "<p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> &quot;sad&quot; occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int strStr(String haystack, String needle) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int strStr(char * haystack, char * needle){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int StrStr(string haystack, string needle) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nvar strStr = function(haystack, needle) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} haystack\n# @param {String} needle\n# @return {Integer}\ndef str_str(haystack, needle)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func strStr(_ haystack: String, _ needle: String) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func strStr(haystack string, needle string) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def strStr(haystack: String, needle: String): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun strStr(haystack: String, needle: String): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn str_str(haystack: String, needle: String) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $haystack\n     * @param String $needle\n     * @return Integer\n     */\n    function strStr($haystack, $needle) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function strStr(haystack: string, needle: string): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (str-str haystack needle)\n  (-> string? string? exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec str_str(Haystack :: unicode:unicode_binary(), Needle :: unicode:unicode_binary()) -> integer().\nstr_str(Haystack, Needle) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec str_str(haystack :: String.t, needle :: String.t) :: integer\n  def str_str(haystack, needle) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int strStr(String haystack, String needle) {\n\n  }\n}"
            }
        ],
        "testcase": "\"sadbutsad\"\n\"sad\"",
        "testable": true,
        "templateMeta": {
            "name": "strStr",
            "params": [
                {
                    "name": "haystack",
                    "type": "string"
                },
                {
                    "name": "needle",
                    "type": "string"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 101,
        "fid": 101,
        "name": "Symmetric Tree",
        "slug": "symmetric-tree",
        "link": "https://leetcode.com/problems/symmetric-tree/description/",
        "percent": 53.343610128642524,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "bloomberg",
            "linkedin",
            "microsoft"
        ],
        "tags": [
            "tree",
            "depth-first-search",
            "breadth-first-search"
        ],
        "totalAC": "1.5M",
        "totalSubmit": "2.8M",
        "likes": 12112,
        "dislikes": 274,
        "desc": "<p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg\" style=\"width: 354px; height: 291px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,4,4,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg\" style=\"width: 308px; height: 258px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,null,3,null,3]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it both recursively and iteratively?",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool isSymmetric(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSymmetric(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Boolean}\ndef is_symmetric(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isSymmetric(_ root: TreeNode?) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSymmetric(root *TreeNode) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isSymmetric(root: TreeNode): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isSymmetric(root: TreeNode?): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function isSymmetric($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSymmetric(root: TreeNode | null): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (is-symmetric root)\n  (-> (or/c tree-node? #f) boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_symmetric(Root :: #tree_node{} | null) -> boolean().\nis_symmetric(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_symmetric(root :: TreeNode.t | nil) :: boolean\n  def is_symmetric(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool isSymmetric(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,2,3,4,4,3]",
        "testable": true,
        "templateMeta": {
            "name": "isSymmetric",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 1,
        "fid": 1,
        "name": "Two Sum",
        "slug": "two-sum",
        "link": "https://leetcode.com/problems/two-sum/description/",
        "percent": 49.38523793196401,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "adobe",
            "airbnb",
            "amazon",
            "apple",
            "bloomberg",
            "dropbox",
            "facebook",
            "linkedin",
            "microsoft",
            "uber",
            "yahoo",
            "yelp"
        ],
        "tags": [
            "array",
            "hash-table"
        ],
        "totalAC": "8.8M",
        "totalSubmit": "17.9M",
        "likes": 42787,
        "dislikes": 1399,
        "desc": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than&nbsp;<code>O(n<sup>2</sup>)&nbsp;</code>time complexity?",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func twoSum(nums []int, target int) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function twoSum($nums, $target) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function twoSum(nums: number[], target: number): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (two-sum nums target)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec two_sum(Nums :: [integer()], Target :: integer()) -> [integer()].\ntwo_sum(Nums, Target) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec two_sum(nums :: [integer], target :: integer) :: [integer]\n  def two_sum(nums, target) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<int> twoSum(List<int> nums, int target) {\n\n  }\n}"
            }
        ],
        "testcase": "[2,7,11,15]\n9",
        "testable": true,
        "templateMeta": {
            "name": "twoSum",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                },
                {
                    "name": "target",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer[]",
                "size": 2
            },
            "manual": false
        }
    },
    {
        "id": 783,
        "fid": 700,
        "name": "Search in a Binary Search Tree",
        "slug": "search-in-a-binary-search-tree",
        "link": "https://leetcode.com/problems/search-in-a-binary-search-tree/description/",
        "percent": 77.42979452933719,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "tree"
        ],
        "totalAC": "603.4K",
        "totalSubmit": "779.3K",
        "likes": 4527,
        "dislikes": 163,
        "desc": "<p>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p>\n\n<p>Find the node in the BST that the node&#39;s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg\" style=\"width: 422px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3], val = 2\n<strong>Output:</strong> [2,1,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg\" style=\"width: 422px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3], val = 5\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 5000]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>7</sup></code></li>\n\t<li><code>root</code> is a binary search tree.</li>\n\t<li><code>1 &lt;= val &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def searchBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* searchBST(struct TreeNode* root, int val){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode SearchBST(TreeNode root, int val) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nvar searchBST = function(root, val) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer} val\n# @return {TreeNode}\ndef search_bst(root, val)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc searchBST(root *TreeNode, val int) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def searchBST(root: TreeNode, `val`: Int): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun searchBST(root: TreeNode?, `val`: Int): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn search_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $val\n     * @return TreeNode\n     */\n    function searchBST($root, $val) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction searchBST(root: TreeNode | null, val: number): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (search-bst root val)\n  (-> (or/c tree-node? #f) exact-integer? (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec search_bst(Root :: #tree_node{} | null, Val :: integer()) -> #tree_node{} | null.\nsearch_bst(Root, Val) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec search_bst(root :: TreeNode.t | nil, val :: integer) :: TreeNode.t | nil\n  def search_bst(root, val) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? searchBST(TreeNode? root, int val) {\n\n  }\n}"
            }
        ],
        "testcase": "[4,2,7,1,3]\n2",
        "testable": true,
        "templateMeta": {
            "name": "searchBST",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                },
                {
                    "name": "val",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "TreeNode"
            }
        }
    },
    {
        "id": 658,
        "fid": 658,
        "name": "Find K Closest Elements",
        "slug": "find-k-closest-elements",
        "link": "https://leetcode.com/problems/find-k-closest-elements/description/",
        "percent": 46.77312035013927,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "google"
        ],
        "tags": [
            "binary-search"
        ],
        "totalAC": "411.2K",
        "totalSubmit": "879.2K",
        "likes": 6603,
        "dislikes": 536,
        "desc": "<p>Given a <strong>sorted</strong> integer array <code>arr</code>, two integers <code>k</code> and <code>x</code>, return the <code>k</code> closest integers to <code>x</code> in the array. The result should also be sorted in ascending order.</p>\n\n<p>An integer <code>a</code> is closer to <code>x</code> than an integer <code>b</code> if:</p>\n\n<ul>\n\t<li><code>|a - x| &lt; |b - x|</code>, or</li>\n\t<li><code>|a - x| == |b - x|</code> and <code>a &lt; b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> arr = [1,2,3,4,5], k = 4, x = 3\n<strong>Output:</strong> [1,2,3,4]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> arr = [1,2,3,4,5], k = 4, x = -1\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>arr</code> is sorted in <strong>ascending</strong> order.</li>\n\t<li><code>-10<sup>4</sup> &lt;= arr[i], x &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def findClosestElements(self, arr, k, x):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :type x: int\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findClosestElements(int* arr, int arrSize, int k, int x, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public IList<int> FindClosestElements(int[] arr, int k, int x) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} arr\n * @param {number} k\n * @param {number} x\n * @return {number[]}\n */\nvar findClosestElements = function(arr, k, x) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} arr\n# @param {Integer} k\n# @param {Integer} x\n# @return {Integer[]}\ndef find_closest_elements(arr, k, x)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func findClosestElements(_ arr: [Int], _ k: Int, _ x: Int) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func findClosestElements(arr []int, k int, x int) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def findClosestElements(arr: Array[Int], k: Int, x: Int): List[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun findClosestElements(arr: IntArray, k: Int, x: Int): List<Int> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn find_closest_elements(arr: Vec<i32>, k: i32, x: i32) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @param Integer $k\n     * @param Integer $x\n     * @return Integer[]\n     */\n    function findClosestElements($arr, $k, $x) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function findClosestElements(arr: number[], k: number, x: number): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (find-closest-elements arr k x)\n  (-> (listof exact-integer?) exact-integer? exact-integer? (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec find_closest_elements(Arr :: [integer()], K :: integer(), X :: integer()) -> [integer()].\nfind_closest_elements(Arr, K, X) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec find_closest_elements(arr :: [integer], k :: integer, x :: integer) :: [integer]\n  def find_closest_elements(arr, k, x) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<int> findClosestElements(List<int> arr, int k, int x) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,3,4,5]\n4\n3",
        "testable": true,
        "templateMeta": {
            "name": "findClosestElements",
            "params": [
                {
                    "name": "arr",
                    "type": "integer[]"
                },
                {
                    "name": "k",
                    "type": "integer"
                },
                {
                    "name": "x",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "list<integer>"
            }
        }
    },
    {
        "id": 747,
        "fid": 746,
        "name": "Min Cost Climbing Stairs",
        "slug": "min-cost-climbing-stairs",
        "link": "https://leetcode.com/problems/min-cost-climbing-stairs/description/",
        "percent": 62.88481140831285,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "array",
            "dynamic-programming"
        ],
        "totalAC": "753.3K",
        "totalSubmit": "1.2M",
        "likes": 8817,
        "dislikes": 1377,
        "desc": "<p>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>i<sup>th</sup></code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p>\n\n<p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p>\n\n<p>Return <em>the minimum cost to reach the top of the floor</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [10,<u>15</u>,20]\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [<u>1</u>,100,<u>1</u>,1,<u>1</u>,100,<u>1</u>,<u>1</u>,100,<u>1</u>]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= cost.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= cost[i] &lt;= 999</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        \"\"\"\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int minCostClimbingStairs(int* cost, int costSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int MinCostClimbingStairs(int[] cost) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} cost\n * @return {number}\n */\nvar minCostClimbingStairs = function(cost) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} cost\n# @return {Integer}\ndef min_cost_climbing_stairs(cost)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func minCostClimbingStairs(_ cost: [Int]) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func minCostClimbingStairs(cost []int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def minCostClimbingStairs(cost: Array[Int]): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun minCostClimbingStairs(cost: IntArray): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn min_cost_climbing_stairs(cost: Vec<i32>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $cost\n     * @return Integer\n     */\n    function minCostClimbingStairs($cost) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function minCostClimbingStairs(cost: number[]): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (min-cost-climbing-stairs cost)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec min_cost_climbing_stairs(Cost :: [integer()]) -> integer().\nmin_cost_climbing_stairs(Cost) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec min_cost_climbing_stairs(cost :: [integer]) :: integer\n  def min_cost_climbing_stairs(cost) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int minCostClimbingStairs(List<int> cost) {\n\n  }\n}"
            }
        ],
        "testcase": "[10,15,20]",
        "testable": true,
        "templateMeta": {
            "name": "minCostClimbingStairs",
            "params": [
                {
                    "name": "cost",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 20,
        "fid": 20,
        "name": "Valid Parentheses",
        "slug": "valid-parentheses",
        "link": "https://leetcode.com/problems/valid-parentheses/description/",
        "percent": 40.39824252754382,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "airbnb",
            "amazon",
            "bloomberg",
            "facebook",
            "google",
            "microsoft",
            "twitter",
            "zenefits"
        ],
        "tags": [
            "string",
            "stack"
        ],
        "totalAC": "3M",
        "totalSubmit": "7.4M",
        "likes": 17790,
        "dislikes": 989,
        "desc": "<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n\n<p>An input string is valid if:</p>\n\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n\t<li>Every close bracket has a corresponding open bracket of the same type.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()[]{}&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(]&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    bool isValid(string s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def isValid(self, s: str) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "bool isValid(char * s){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public bool IsValid(string s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @return {Boolean}\ndef is_valid(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func isValid(_ s: String) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func isValid(s string) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def isValid(s: String): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun isValid(s: String): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn is_valid(s: String) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function isValid($s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function isValid(s: string): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (is-valid s)\n  (-> string? boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec is_valid(S :: unicode:unicode_binary()) -> boolean().\nis_valid(S) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec is_valid(s :: String.t) :: boolean\n  def is_valid(s) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  bool isValid(String s) {\n\n  }\n}"
            }
        ],
        "testcase": "\"()\"",
        "testable": true,
        "templateMeta": {
            "name": "isValid",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 349,
        "fid": 349,
        "name": "Intersection of Two Arrays",
        "slug": "intersection-of-two-arrays",
        "link": "https://leetcode.com/problems/intersection-of-two-arrays/description/",
        "percent": 70.65391689544067,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "twosigma"
        ],
        "tags": [
            "hash-table",
            "two-pointers",
            "binary-search",
            "sort"
        ],
        "totalAC": "803.3K",
        "totalSubmit": "1.1M",
        "likes": 4223,
        "dislikes": 2070,
        "desc": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [9,4]\n<strong>Explanation:</strong> [4,9] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int[] Intersection(int[] nums1, int[] nums2) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function(nums1, nums2) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer[]}\ndef intersection(nums1, nums2)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func intersection(nums1 []int, nums2 []int) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def intersection(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun intersection(nums1: IntArray, nums2: IntArray): IntArray {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn intersection(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer[]\n     */\n    function intersection($nums1, $nums2) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function intersection(nums1: number[], nums2: number[]): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (intersection nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec intersection(Nums1 :: [integer()], Nums2 :: [integer()]) -> [integer()].\nintersection(Nums1, Nums2) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec intersection(nums1 :: [integer], nums2 :: [integer]) :: [integer]\n  def intersection(nums1, nums2) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<int> intersection(List<int> nums1, List<int> nums2) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,2,1]\n[2,2]",
        "testable": true,
        "templateMeta": {
            "name": "intersection",
            "params": [
                {
                    "name": "nums1",
                    "type": "integer[]"
                },
                {
                    "name": "nums2",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "integer[]"
            }
        }
    },
    {
        "id": 206,
        "fid": 206,
        "name": "Reverse Linked List",
        "slug": "reverse-linked-list",
        "link": "https://leetcode.com/problems/reverse-linked-list/description/",
        "percent": 73.10748072925045,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "adobe",
            "amazon",
            "apple",
            "bloomberg",
            "facebook",
            "microsoft",
            "snapchat",
            "twitter",
            "uber",
            "yahoo",
            "yelp",
            "zenefits"
        ],
        "tags": [
            "linked-list"
        ],
        "totalAC": "2.9M",
        "totalSubmit": "3.9M",
        "likes": 16465,
        "dislikes": 279,
        "desc": "<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [5,4,3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* reverseList(struct ListNode* head){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function(head) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef reverse_list(head)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func reverseList(_ head: ListNode?) -> ListNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseList(head *ListNode) *ListNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def reverseList(head: ListNode): ListNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun reverseList(head: ListNode?): ListNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function reverseList($head) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction reverseList(head: ListNode | null): ListNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (reverse-list head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec reverse_list(Head :: #list_node{} | null) -> #list_node{} | null.\nreverse_list(Head) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec reverse_list(head :: ListNode.t | nil) :: ListNode.t | nil\n  def reverse_list(head) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? reverseList(ListNode? head) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,3,4,5]",
        "testable": true,
        "templateMeta": {
            "name": "reverseList",
            "params": [
                {
                    "name": "head",
                    "type": "ListNode",
                    "dealloc": false
                }
            ],
            "return": {
                "type": "ListNode",
                "dealloc": true
            }
        }
    },
    {
        "id": 838,
        "fid": 707,
        "name": "Design Linked List",
        "slug": "design-linked-list",
        "link": "https://leetcode.com/problems/design-linked-list/description/",
        "percent": 27.56154967360666,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "linked-list",
            "design"
        ],
        "totalAC": "243K",
        "totalSubmit": "881.7K",
        "likes": 2010,
        "dislikes": 1376,
        "desc": "<p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br />\nA node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br />\nIf you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>\n\n<p>Implement the <code>MyLinkedList</code> class:</p>\n\n<ul>\n\t<li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li>\n\t<li><code>int get(int index)</code> Get the value of the <code>index<sup>th</sup></code> node in the linked list. If the index is invalid, return <code>-1</code>.</li>\n\t<li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>\n\t<li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li>\n\t<li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code> before the <code>index<sup>th</sup></code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li>\n\t<li><code>void deleteAtIndex(int index)</code> Delete the <code>index<sup>th</sup></code> node in the linked list, if the index is valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n<strong>Output</strong>\n[null, null, null, null, 2, null, 3]\n\n<strong>Explanation</strong>\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // return 2\nmyLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3\nmyLinkedList.get(1);              // return 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= index, val &lt;= 1000</code></li>\n\t<li>Please do not use the built-in LinkedList library.</li>\n\t<li>At most <code>2000</code> calls will be made to <code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> and <code>deleteAtIndex</code>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class MyLinkedList {\npublic:\n    MyLinkedList() {\n        \n    }\n    \n    int get(int index) {\n        \n    }\n    \n    void addAtHead(int val) {\n        \n    }\n    \n    void addAtTail(int val) {\n        \n    }\n    \n    void addAtIndex(int index, int val) {\n        \n    }\n    \n    void deleteAtIndex(int index) {\n        \n    }\n};\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList* obj = new MyLinkedList();\n * int param_1 = obj->get(index);\n * obj->addAtHead(val);\n * obj->addAtTail(val);\n * obj->addAtIndex(index,val);\n * obj->deleteAtIndex(index);\n */"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class MyLinkedList {\n\n    public MyLinkedList() {\n        \n    }\n    \n    public int get(int index) {\n        \n    }\n    \n    public void addAtHead(int val) {\n        \n    }\n    \n    public void addAtTail(int val) {\n        \n    }\n    \n    public void addAtIndex(int index, int val) {\n        \n    }\n    \n    public void deleteAtIndex(int index) {\n        \n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList obj = new MyLinkedList();\n * int param_1 = obj.get(index);\n * obj.addAtHead(val);\n * obj.addAtTail(val);\n * obj.addAtIndex(index,val);\n * obj.deleteAtIndex(index);\n */"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class MyLinkedList(object):\n\n    def __init__(self):\n        \n\n    def get(self, index):\n        \"\"\"\n        :type index: int\n        :rtype: int\n        \"\"\"\n        \n\n    def addAtHead(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def addAtTail(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def addAtIndex(self, index, val):\n        \"\"\"\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def deleteAtIndex(self, index):\n        \"\"\"\n        :type index: int\n        :rtype: None\n        \"\"\"\n        \n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)"
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class MyLinkedList:\n\n    def __init__(self):\n        \n\n    def get(self, index: int) -> int:\n        \n\n    def addAtHead(self, val: int) -> None:\n        \n\n    def addAtTail(self, val: int) -> None:\n        \n\n    def addAtIndex(self, index: int, val: int) -> None:\n        \n\n    def deleteAtIndex(self, index: int) -> None:\n        \n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)"
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "\n\n\ntypedef struct {\n    \n} MyLinkedList;\n\n\nMyLinkedList* myLinkedListCreate() {\n    \n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n  \n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n  \n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n  \n}\n\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n  \n}\n\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n  \n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    \n}\n\n/**\n * Your MyLinkedList struct will be instantiated and called as such:\n * MyLinkedList* obj = myLinkedListCreate();\n * int param_1 = myLinkedListGet(obj, index);\n \n * myLinkedListAddAtHead(obj, val);\n \n * myLinkedListAddAtTail(obj, val);\n \n * myLinkedListAddAtIndex(obj, index, val);\n \n * myLinkedListDeleteAtIndex(obj, index);\n \n * myLinkedListFree(obj);\n*/"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class MyLinkedList {\n\n    public MyLinkedList() {\n        \n    }\n    \n    public int Get(int index) {\n        \n    }\n    \n    public void AddAtHead(int val) {\n        \n    }\n    \n    public void AddAtTail(int val) {\n        \n    }\n    \n    public void AddAtIndex(int index, int val) {\n        \n    }\n    \n    public void DeleteAtIndex(int index) {\n        \n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList obj = new MyLinkedList();\n * int param_1 = obj.Get(index);\n * obj.AddAtHead(val);\n * obj.AddAtTail(val);\n * obj.AddAtIndex(index,val);\n * obj.DeleteAtIndex(index);\n */"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "\nvar MyLinkedList = function() {\n    \n};\n\n/** \n * @param {number} index\n * @return {number}\n */\nMyLinkedList.prototype.get = function(index) {\n    \n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtHead = function(val) {\n    \n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtTail = function(val) {\n    \n};\n\n/** \n * @param {number} index \n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtIndex = function(index, val) {\n    \n};\n\n/** \n * @param {number} index\n * @return {void}\n */\nMyLinkedList.prototype.deleteAtIndex = function(index) {\n    \n};\n\n/** \n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index,val)\n * obj.deleteAtIndex(index)\n */"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "class MyLinkedList\n    def initialize()\n        \n    end\n\n\n=begin\n    :type index: Integer\n    :rtype: Integer\n=end\n    def get(index)\n        \n    end\n\n\n=begin\n    :type val: Integer\n    :rtype: Void\n=end\n    def add_at_head(val)\n        \n    end\n\n\n=begin\n    :type val: Integer\n    :rtype: Void\n=end\n    def add_at_tail(val)\n        \n    end\n\n\n=begin\n    :type index: Integer\n    :type val: Integer\n    :rtype: Void\n=end\n    def add_at_index(index, val)\n        \n    end\n\n\n=begin\n    :type index: Integer\n    :rtype: Void\n=end\n    def delete_at_index(index)\n        \n    end\n\n\nend\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList.new()\n# param_1 = obj.get(index)\n# obj.add_at_head(val)\n# obj.add_at_tail(val)\n# obj.add_at_index(index, val)\n# obj.delete_at_index(index)"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "\nclass MyLinkedList {\n\n    init() {\n        \n    }\n    \n    func get(_ index: Int) -> Int {\n        \n    }\n    \n    func addAtHead(_ val: Int) {\n        \n    }\n    \n    func addAtTail(_ val: Int) {\n        \n    }\n    \n    func addAtIndex(_ index: Int, _ val: Int) {\n        \n    }\n    \n    func deleteAtIndex(_ index: Int) {\n        \n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * let obj = MyLinkedList()\n * let ret_1: Int = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index, val)\n * obj.deleteAtIndex(index)\n */"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "type MyLinkedList struct {\n    \n}\n\n\nfunc Constructor() MyLinkedList {\n    \n}\n\n\nfunc (this *MyLinkedList) Get(index int) int {\n    \n}\n\n\nfunc (this *MyLinkedList) AddAtHead(val int)  {\n    \n}\n\n\nfunc (this *MyLinkedList) AddAtTail(val int)  {\n    \n}\n\n\nfunc (this *MyLinkedList) AddAtIndex(index int, val int)  {\n    \n}\n\n\nfunc (this *MyLinkedList) DeleteAtIndex(index int)  {\n    \n}\n\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Get(index);\n * obj.AddAtHead(val);\n * obj.AddAtTail(val);\n * obj.AddAtIndex(index,val);\n * obj.DeleteAtIndex(index);\n */"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "class MyLinkedList() {\n\n    def get(index: Int): Int = {\n        \n    }\n\n    def addAtHead(`val`: Int) {\n        \n    }\n\n    def addAtTail(`val`: Int) {\n        \n    }\n\n    def addAtIndex(index: Int, `val`: Int) {\n        \n    }\n\n    def deleteAtIndex(index: Int) {\n        \n    }\n\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(`val`)\n * obj.addAtTail(`val`)\n * obj.addAtIndex(index,`val`)\n * obj.deleteAtIndex(index)\n */"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class MyLinkedList() {\n\n    fun get(index: Int): Int {\n        \n    }\n\n    fun addAtHead(`val`: Int) {\n        \n    }\n\n    fun addAtTail(`val`: Int) {\n        \n    }\n\n    fun addAtIndex(index: Int, `val`: Int) {\n        \n    }\n\n    fun deleteAtIndex(index: Int) {\n        \n    }\n\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(`val`)\n * obj.addAtTail(`val`)\n * obj.addAtIndex(index,`val`)\n * obj.deleteAtIndex(index)\n */"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "struct MyLinkedList {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyLinkedList {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn get(&self, index: i32) -> i32 {\n        \n    }\n    \n    fn add_at_head(&self, val: i32) {\n        \n    }\n    \n    fn add_at_tail(&self, val: i32) {\n        \n    }\n    \n    fn add_at_index(&self, index: i32, val: i32) {\n        \n    }\n    \n    fn delete_at_index(&self, index: i32) {\n        \n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * let obj = MyLinkedList::new();\n * let ret_1: i32 = obj.get(index);\n * obj.add_at_head(val);\n * obj.add_at_tail(val);\n * obj.add_at_index(index, val);\n * obj.delete_at_index(index);\n */"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class MyLinkedList {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $index\n     * @return Integer\n     */\n    function get($index) {\n        \n    }\n  \n    /**\n     * @param Integer $val\n     * @return NULL\n     */\n    function addAtHead($val) {\n        \n    }\n  \n    /**\n     * @param Integer $val\n     * @return NULL\n     */\n    function addAtTail($val) {\n        \n    }\n  \n    /**\n     * @param Integer $index\n     * @param Integer $val\n     * @return NULL\n     */\n    function addAtIndex($index, $val) {\n        \n    }\n  \n    /**\n     * @param Integer $index\n     * @return NULL\n     */\n    function deleteAtIndex($index) {\n        \n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * $obj = MyLinkedList();\n * $ret_1 = $obj->get($index);\n * $obj->addAtHead($val);\n * $obj->addAtTail($val);\n * $obj->addAtIndex($index, $val);\n * $obj->deleteAtIndex($index);\n */"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "class MyLinkedList {\n    constructor() {\n\n    }\n\n    get(index: number): number {\n\n    }\n\n    addAtHead(val: number): void {\n\n    }\n\n    addAtTail(val: number): void {\n\n    }\n\n    addAtIndex(index: number, val: number): void {\n\n    }\n\n    deleteAtIndex(index: number): void {\n\n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index,val)\n * obj.deleteAtIndex(index)\n */"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define my-linked-list%\n  (class object%\n    (super-new)\n    (init-field)\n    \n    ; get : exact-integer? -> exact-integer?\n    (define/public (get index)\n\n      )\n    ; add-at-head : exact-integer? -> void?\n    (define/public (add-at-head val)\n\n      )\n    ; add-at-tail : exact-integer? -> void?\n    (define/public (add-at-tail val)\n\n      )\n    ; add-at-index : exact-integer? exact-integer? -> void?\n    (define/public (add-at-index index val)\n\n      )\n    ; delete-at-index : exact-integer? -> void?\n    (define/public (delete-at-index index)\n\n      )))\n\n;; Your my-linked-list% object will be instantiated and called as such:\n;; (define obj (new my-linked-list%))\n;; (define param_1 (send obj get index))\n;; (send obj add-at-head val)\n;; (send obj add-at-tail val)\n;; (send obj add-at-index index val)\n;; (send obj delete-at-index index)"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec my_linked_list_init_() -> any().\nmy_linked_list_init_() ->\n  .\n\n-spec my_linked_list_get(Index :: integer()) -> integer().\nmy_linked_list_get(Index) ->\n  .\n\n-spec my_linked_list_add_at_head(Val :: integer()) -> any().\nmy_linked_list_add_at_head(Val) ->\n  .\n\n-spec my_linked_list_add_at_tail(Val :: integer()) -> any().\nmy_linked_list_add_at_tail(Val) ->\n  .\n\n-spec my_linked_list_add_at_index(Index :: integer(), Val :: integer()) -> any().\nmy_linked_list_add_at_index(Index, Val) ->\n  .\n\n-spec my_linked_list_delete_at_index(Index :: integer()) -> any().\nmy_linked_list_delete_at_index(Index) ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_linked_list_init_(),\n%% Param_1 = my_linked_list_get(Index),\n%% my_linked_list_add_at_head(Val),\n%% my_linked_list_add_at_tail(Val),\n%% my_linked_list_add_at_index(Index, Val),\n%% my_linked_list_delete_at_index(Index),\n\n%% my_linked_list_init_ will be called before every test case, in which you can do some necessary initializations."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule MyLinkedList do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec get(index :: integer) :: integer\n  def get(index) do\n\n  end\n\n  @spec add_at_head(val :: integer) :: any\n  def add_at_head(val) do\n\n  end\n\n  @spec add_at_tail(val :: integer) :: any\n  def add_at_tail(val) do\n\n  end\n\n  @spec add_at_index(index :: integer, val :: integer) :: any\n  def add_at_index(index, val) do\n\n  end\n\n  @spec delete_at_index(index :: integer) :: any\n  def delete_at_index(index) do\n\n  end\nend\n\n# Your functions will be called as such:\n# MyLinkedList.init_()\n# param_1 = MyLinkedList.get(index)\n# MyLinkedList.add_at_head(val)\n# MyLinkedList.add_at_tail(val)\n# MyLinkedList.add_at_index(index, val)\n# MyLinkedList.delete_at_index(index)\n\n# MyLinkedList.init_ will be called before every test case, in which you can do some necessary initializations."
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class MyLinkedList {\n\n  MyLinkedList() {\n\n  }\n  \n  int get(int index) {\n\n  }\n  \n  void addAtHead(int val) {\n\n  }\n  \n  void addAtTail(int val) {\n\n  }\n  \n  void addAtIndex(int index, int val) {\n\n  }\n  \n  void deleteAtIndex(int index) {\n\n  }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList obj = MyLinkedList();\n * int param1 = obj.get(index);\n * obj.addAtHead(val);\n * obj.addAtTail(val);\n * obj.addAtIndex(index,val);\n * obj.deleteAtIndex(index);\n */"
            }
        ],
        "testcase": "[\"MyLinkedList\",\"addAtHead\",\"addAtTail\",\"addAtIndex\",\"get\",\"deleteAtIndex\",\"get\"]\n[[],[1],[3],[1,2],[1],[1],[1]]",
        "testable": true,
        "templateMeta": {
            "classname": "MyLinkedList",
            "constructor": {
                "params": []
            },
            "methods": [
                {
                    "params": [
                        {
                            "type": "integer",
                            "name": "index"
                        }
                    ],
                    "return": {
                        "type": "integer"
                    },
                    "name": "get"
                },
                {
                    "params": [
                        {
                            "type": "integer",
                            "name": "val"
                        }
                    ],
                    "return": {
                        "type": "void"
                    },
                    "name": "addAtHead"
                },
                {
                    "params": [
                        {
                            "type": "integer",
                            "name": "val"
                        }
                    ],
                    "return": {
                        "type": "void"
                    },
                    "name": "addAtTail"
                },
                {
                    "params": [
                        {
                            "type": "integer",
                            "name": "index"
                        },
                        {
                            "type": "integer",
                            "name": "val"
                        }
                    ],
                    "return": {
                        "type": "void"
                    },
                    "name": "addAtIndex"
                },
                {
                    "params": [
                        {
                            "type": "integer",
                            "name": "index"
                        }
                    ],
                    "return": {
                        "type": "void"
                    },
                    "name": "deleteAtIndex"
                }
            ],
            "return": {
                "type": "boolean"
            },
            "systemdesign": true
        }
    },
    {
        "id": 227,
        "fid": 227,
        "name": "Basic Calculator II",
        "slug": "basic-calculator-ii",
        "link": "https://leetcode.com/problems/basic-calculator-ii/description/",
        "percent": 42.3434949486037,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "airbnb"
        ],
        "tags": [
            "string"
        ],
        "totalAC": "500.2K",
        "totalSubmit": "1.2M",
        "likes": 5277,
        "dislikes": 681,
        "desc": "<p>Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>.&nbsp;</p>\n\n<p>The integer division should truncate toward zero.</p>\n\n<p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.</p>\n\n<p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"3+2*2\"\n<strong>Output:</strong> 7\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \" 3/2 \"\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \" 3+5 / 2 \"\n<strong>Output:</strong> 5\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of integers and operators <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> separated by some number of spaces.</li>\n\t<li><code>s</code> represents <strong>a valid expression</strong>.</li>\n\t<li>All the integers in the expression are non-negative integers in the range <code>[0, 2<sup>31</sup> - 1]</code>.</li>\n\t<li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit integer</strong>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int calculate(string s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int calculate(String s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def calculate(self, s: str) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int calculate(char * s){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int Calculate(string s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar calculate = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @return {Integer}\ndef calculate(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func calculate(_ s: String) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func calculate(s string) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def calculate(s: String): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun calculate(s: String): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn calculate(s: String) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function calculate($s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function calculate(s: string): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (calculate s)\n  (-> string? exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec calculate(S :: unicode:unicode_binary()) -> integer().\ncalculate(S) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec calculate(s :: String.t) :: integer\n  def calculate(s) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int calculate(String s) {\n\n  }\n}"
            }
        ],
        "testcase": "\"3+2*2\"",
        "testable": true,
        "templateMeta": {
            "name": "calculate",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 617,
        "fid": 617,
        "name": "Merge Two Binary Trees",
        "slug": "merge-two-binary-trees",
        "link": "https://leetcode.com/problems/merge-two-binary-trees/description/",
        "percent": 78.61099617069011,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "amazon"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "657.4K",
        "totalSubmit": "836.2K",
        "likes": 7778,
        "dislikes": 272,
        "desc": "<p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p>\n\n<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>\n\n<p>Return <em>the merged tree</em>.</p>\n\n<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/merge.jpg\" style=\"width: 600px; height: 163px;\" />\n<pre>\n<strong>Input:</strong> root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n<strong>Output:</strong> [3,4,5,5,4,null,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root1 = [1], root2 = [1,2]\n<strong>Output:</strong> [2,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both trees is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def mergeTrees(self, root1, root2):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode MergeTrees(TreeNode root1, TreeNode root2) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {TreeNode}\n */\nvar mergeTrees = function(root1, root2) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root1\n# @param {TreeNode} root2\n# @return {TreeNode}\ndef merge_trees(root1, root2)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func mergeTrees(_ root1: TreeNode?, _ root2: TreeNode?) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def mergeTrees(root1: TreeNode, root2: TreeNode): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun mergeTrees(root1: TreeNode?, root2: TreeNode?): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn merge_trees(root1: Option<Rc<RefCell<TreeNode>>>, root2: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root1\n     * @param TreeNode $root2\n     * @return TreeNode\n     */\n    function mergeTrees($root1, $root2) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (merge-trees root1 root2)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f) (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec merge_trees(Root1 :: #tree_node{} | null, Root2 :: #tree_node{} | null) -> #tree_node{} | null.\nmerge_trees(Root1, Root2) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec merge_trees(root1 :: TreeNode.t | nil, root2 :: TreeNode.t | nil) :: TreeNode.t | nil\n  def merge_trees(root1, root2) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? mergeTrees(TreeNode? root1, TreeNode? root2) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,3,2,5]\n[2,1,3,null,4,null,7]",
        "testable": true,
        "templateMeta": {
            "name": "mergeTrees",
            "params": [
                {
                    "name": "root1",
                    "type": "TreeNode",
                    "dealloc": false
                },
                {
                    "name": "root2",
                    "type": "TreeNode",
                    "dealloc": false
                }
            ],
            "return": {
                "type": "TreeNode"
            }
        }
    },
    {
        "id": 530,
        "fid": 530,
        "name": "Minimum Absolute Difference in BST",
        "slug": "minimum-absolute-difference-in-bst",
        "link": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/",
        "percent": 56.83224460440207,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "google"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "191.2K",
        "totalSubmit": "336.5K",
        "likes": 2601,
        "dislikes": 140,
        "desc": "<p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,6,1,3]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg\" style=\"width: 282px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,0,48,null,null,12,49]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 783: <a href=\"https://leetcode.com/problems/minimum-distance-between-bst-nodes/\" target=\"_blank\">https://leetcode.com/problems/minimum-distance-between-bst-nodes/</a></p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int getMinimumDifference(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int getMinimumDifference(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint getMinimumDifference(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int GetMinimumDifference(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar getMinimumDifference = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef get_minimum_difference(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func getMinimumDifference(_ root: TreeNode?) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc getMinimumDifference(root *TreeNode) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def getMinimumDifference(root: TreeNode): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun getMinimumDifference(root: TreeNode?): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn get_minimum_difference(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function getMinimumDifference($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction getMinimumDifference(root: TreeNode | null): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (get-minimum-difference root)\n  (-> (or/c tree-node? #f) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec get_minimum_difference(Root :: #tree_node{} | null) -> integer().\nget_minimum_difference(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec get_minimum_difference(root :: TreeNode.t | nil) :: integer\n  def get_minimum_difference(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int getMinimumDifference(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[4,2,6,1,3]",
        "testable": true,
        "templateMeta": {
            "name": "getMinimumDifference",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 108,
        "fid": 108,
        "name": "Convert Sorted Array to Binary Search Tree",
        "slug": "convert-sorted-array-to-binary-search-tree",
        "link": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/",
        "percent": 69.49873342141744,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "airbnb"
        ],
        "tags": [
            "tree",
            "depth-first-search"
        ],
        "totalAC": "940.5K",
        "totalSubmit": "1.4M",
        "likes": 8983,
        "dislikes": 454,
        "desc": "<p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg\" style=\"width: 302px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> nums = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg\" style=\"width: 302px; height: 222px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree.jpg\" style=\"width: 342px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,3]\n<strong>Output:</strong> [3,1]\n<strong>Explanation:</strong> [1,null,3] and [3,1] are both height-balanced BSTs.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* sortedArrayToBST(int* nums, int numsSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode SortedArrayToBST(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function(nums) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {Integer[]} nums\n# @return {TreeNode}\ndef sorted_array_to_bst(nums)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func sortedArrayToBST(_ nums: [Int]) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def sortedArrayToBST(nums: Array[Int]): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun sortedArrayToBST(nums: IntArray): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn sorted_array_to_bst(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return TreeNode\n     */\n    function sortedArrayToBST($nums) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction sortedArrayToBST(nums: number[]): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (sorted-array-to-bst nums)\n  (-> (listof exact-integer?) (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec sorted_array_to_bst(Nums :: [integer()]) -> #tree_node{} | null.\nsorted_array_to_bst(Nums) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec sorted_array_to_bst(nums :: [integer]) :: TreeNode.t | nil\n  def sorted_array_to_bst(nums) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? sortedArrayToBST(List<int> nums) {\n\n  }\n}"
            }
        ],
        "testcase": "[-10,-3,0,5,9]",
        "testable": true,
        "templateMeta": {
            "name": "sortedArrayToBST",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "TreeNode",
                "dealloc": true
            }
        }
    },
    {
        "id": 24,
        "fid": 24,
        "name": "Swap Nodes in Pairs",
        "slug": "swap-nodes-in-pairs",
        "link": "https://leetcode.com/problems/swap-nodes-in-pairs/description/",
        "percent": 60.945948800270365,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "bloomberg",
            "microsoft",
            "uber"
        ],
        "tags": [
            "linked-list"
        ],
        "totalAC": "1M",
        "totalSubmit": "1.7M",
        "likes": 9005,
        "dislikes": 351,
        "desc": "<p>Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [2,1,4,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the&nbsp;list&nbsp;is in the range <code>[0, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* swapPairs(struct ListNode* head){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode SwapPairs(ListNode head) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef swap_pairs(head)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func swapPairs(_ head: ListNode?) -> ListNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def swapPairs(head: ListNode): ListNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun swapPairs(head: ListNode?): ListNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function swapPairs($head) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (swap-pairs head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec swap_pairs(Head :: #list_node{} | null) -> #list_node{} | null.\nswap_pairs(Head) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec swap_pairs(head :: ListNode.t | nil) :: ListNode.t | nil\n  def swap_pairs(head) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? swapPairs(ListNode? head) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,3,4]",
        "testable": true,
        "templateMeta": {
            "name": "swapPairs",
            "params": [
                {
                    "name": "head",
                    "type": "ListNode"
                }
            ],
            "return": {
                "type": "ListNode"
            }
        }
    },
    {
        "id": 17,
        "fid": 17,
        "name": "Letter Combinations of a Phone Number",
        "slug": "letter-combinations-of-a-phone-number",
        "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/",
        "percent": 56.14896463029384,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "amazon",
            "dropbox",
            "facebook",
            "google",
            "uber"
        ],
        "tags": [
            "string",
            "backtracking"
        ],
        "totalAC": "1.5M",
        "totalSubmit": "2.6M",
        "likes": 13942,
        "dislikes": 808,
        "desc": "<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>\n\n<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 300px; height: 243px;\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;23&quot;\n<strong>Output:</strong> [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;&quot;\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;2&quot;\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= digits.length &lt;= 4</code></li>\n\t<li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** letterCombinations(char * digits, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public IList<string> LetterCombinations(string digits) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} digits\n * @return {string[]}\n */\nvar letterCombinations = function(digits) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} digits\n# @return {String[]}\ndef letter_combinations(digits)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func letterCombinations(_ digits: String) -> [String] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func letterCombinations(digits string) []string {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def letterCombinations(digits: String): List[String] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun letterCombinations(digits: String): List<String> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn letter_combinations(digits: String) -> Vec<String> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $digits\n     * @return String[]\n     */\n    function letterCombinations($digits) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function letterCombinations(digits: string): string[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (letter-combinations digits)\n  (-> string? (listof string?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec letter_combinations(Digits :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nletter_combinations(Digits) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec letter_combinations(digits :: String.t) :: [String.t]\n  def letter_combinations(digits) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<String> letterCombinations(String digits) {\n\n  }\n}"
            }
        ],
        "testcase": "\"23\"",
        "testable": true,
        "templateMeta": {
            "name": "letterCombinations",
            "params": [
                {
                    "name": "digits",
                    "type": "string"
                }
            ],
            "return": {
                "type": "list<string>"
            }
        }
    },
    {
        "id": 236,
        "fid": 236,
        "name": "Lowest Common Ancestor of a Binary Tree",
        "slug": "lowest-common-ancestor-of-a-binary-tree",
        "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/",
        "percent": 58.46690359986049,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "amazon",
            "apple",
            "facebook",
            "linkedin",
            "microsoft"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "1.2M",
        "totalSubmit": "2.1M",
        "likes": 13368,
        "dislikes": 321,
        "desc": "<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the tree.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    \n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @param {TreeNode} p\n# @param {TreeNode} q\n# @return {TreeNode}\ndef lowest_common_ancestor(root, p, q)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\n\nclass Solution {\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n  \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\n\nobject Solution {\n    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int = 0) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\n\nclass Solution {\n    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\n\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return TreeNode\n     */\n    function lowestCommonAncestor($root, $p, $q) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n\t\n};"
            }
        ],
        "testcase": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n1",
        "testable": true,
        "templateMeta": {
            "name": "lowestCommonAncestor",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                },
                {
                    "name": "p",
                    "type": "integer"
                },
                {
                    "name": "q",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "TreeNode"
            },
            "manual": true
        }
    },
    {
        "id": 404,
        "fid": 404,
        "name": "Sum of Left Leaves",
        "slug": "sum-of-left-leaves",
        "link": "https://leetcode.com/problems/sum-of-left-leaves/description/",
        "percent": 56.51703586877298,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "facebook"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "416.4K",
        "totalSubmit": "736.8K",
        "likes": 4239,
        "dislikes": 269,
        "desc": "<p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p>\n\n<p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 24\n<strong>Explanation:</strong> There are two left leaves in the binary tree, with values 9 and 15 respectively.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint sumOfLeftLeaves(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int SumOfLeftLeaves(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumOfLeftLeaves = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef sum_of_left_leaves(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func sumOfLeftLeaves(_ root: TreeNode?) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sumOfLeftLeaves(root *TreeNode) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def sumOfLeftLeaves(root: TreeNode): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun sumOfLeftLeaves(root: TreeNode?): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn sum_of_left_leaves(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function sumOfLeftLeaves($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction sumOfLeftLeaves(root: TreeNode | null): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (sum-of-left-leaves root)\n  (-> (or/c tree-node? #f) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec sum_of_left_leaves(Root :: #tree_node{} | null) -> integer().\nsum_of_left_leaves(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec sum_of_left_leaves(root :: TreeNode.t | nil) :: integer\n  def sum_of_left_leaves(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int sumOfLeftLeaves(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[3,9,20,null,null,15,7]",
        "testable": true,
        "templateMeta": {
            "name": "sumOfLeftLeaves",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 27,
        "fid": 27,
        "name": "Remove Element",
        "slug": "remove-element",
        "link": "https://leetcode.com/problems/remove-element/description/",
        "percent": 52.63384038355977,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "array",
            "two-pointers"
        ],
        "totalAC": "1.6M",
        "totalSubmit": "3.1M",
        "likes": 5186,
        "dislikes": 6942,
        "desc": "<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>. The relative order of the elements may be changed.</p>\n\n<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p>\n\n<p>Return <code>k</code><em> after placing the final result in the first </em><code>k</code><em> slots of </em><code>nums</code>.</p>\n\n<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i &lt; actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,2,3], val = 3\n<strong>Output:</strong> 2, nums = [2,2,_,_]\n<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,2,3,0,4,2], val = 2\n<strong>Output:</strong> 5, nums = [0,1,4,0,3,_,_,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int removeElement(int* nums, int numsSize, int val){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int RemoveElement(int[] nums, int val) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @param {Integer} val\n# @return {Integer}\ndef remove_element(nums, val)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func removeElement(nums []int, val int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def removeElement(nums: Array[Int], `val`: Int): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun removeElement(nums: IntArray, `val`: Int): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $val\n     * @return Integer\n     */\n    function removeElement(&$nums, $val) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function removeElement(nums: number[], val: number): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (remove-element nums val)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int removeElement(List<int> nums, int val) {\n\n  }\n}"
            }
        ],
        "testcase": "[3,2,2,3]\n3",
        "testable": true,
        "templateMeta": {
            "name": "removeElement",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                },
                {
                    "name": "val",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer"
            },
            "output": {
                "paramindex": 0,
                "size": "ret"
            }
        }
    },
    {
        "id": 454,
        "fid": 454,
        "name": "4Sum II",
        "slug": "4sum-ii",
        "link": "https://leetcode.com/problems/4sum-ii/description/",
        "percent": 57.25966432879843,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "hash-table",
            "binary-search"
        ],
        "totalAC": "284.6K",
        "totalSubmit": "497.1K",
        "likes": 4341,
        "dislikes": 124,
        "desc": "<p>Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j, k, l &lt; n</code></li>\n\t<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThe two tuples are:\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>n == nums3.length</code></li>\n\t<li><code>n == nums4.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-2<sup>28</sup> &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2<sup>28</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def fourSumCount(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int FourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number[]} nums3\n * @param {number[]} nums4\n * @return {number}\n */\nvar fourSumCount = function(nums1, nums2, nums3, nums4) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer[]} nums3\n# @param {Integer[]} nums4\n# @return {Integer}\ndef four_sum_count(nums1, nums2, nums3, nums4)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func fourSumCount(_ nums1: [Int], _ nums2: [Int], _ nums3: [Int], _ nums4: [Int]) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def fourSumCount(nums1: Array[Int], nums2: Array[Int], nums3: Array[Int], nums4: Array[Int]): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun fourSumCount(nums1: IntArray, nums2: IntArray, nums3: IntArray, nums4: IntArray): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn four_sum_count(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>, nums4: Vec<i32>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer[] $nums3\n     * @param Integer[] $nums4\n     * @return Integer\n     */\n    function fourSumCount($nums1, $nums2, $nums3, $nums4) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (four-sum-count nums1 nums2 nums3 nums4)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec four_sum_count(Nums1 :: [integer()], Nums2 :: [integer()], Nums3 :: [integer()], Nums4 :: [integer()]) -> integer().\nfour_sum_count(Nums1, Nums2, Nums3, Nums4) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec four_sum_count(nums1 :: [integer], nums2 :: [integer], nums3 :: [integer], nums4 :: [integer]) :: integer\n  def four_sum_count(nums1, nums2, nums3, nums4) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int fourSumCount(List<int> nums1, List<int> nums2, List<int> nums3, List<int> nums4) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2]\n[-2,-1]\n[-1,2]\n[0,2]",
        "testable": true,
        "templateMeta": {
            "name": "fourSumCount",
            "params": [
                {
                    "name": "nums1",
                    "type": "integer[]"
                },
                {
                    "name": "nums2",
                    "type": "integer[]"
                },
                {
                    "name": "nums3",
                    "type": "integer[]"
                },
                {
                    "name": "nums4",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 1128,
        "fid": 1047,
        "name": "Remove All Adjacent Duplicates In String",
        "slug": "remove-all-adjacent-duplicates-in-string",
        "link": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/",
        "percent": 69.94514772148231,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "stack"
        ],
        "totalAC": "420.1K",
        "totalSubmit": "600.6K",
        "likes": 5363,
        "dislikes": 211,
        "desc": "<p>You are given a string <code>s</code> consisting of lowercase English letters. A <strong>duplicate removal</strong> consists of choosing two <strong>adjacent</strong> and <strong>equal</strong> letters and removing them.</p>\n\n<p>We repeatedly make <strong>duplicate removals</strong> on <code>s</code> until we no longer can.</p>\n\n<p>Return <em>the final string after all such duplicate removals have been made</em>. It can be proven that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abbaca&quot;\n<strong>Output:</strong> &quot;ca&quot;\n<strong>Explanation:</strong> \nFor example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;azxxzy&quot;\n<strong>Output:</strong> &quot;ay&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    string removeDuplicates(string s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public String removeDuplicates(String s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def removeDuplicates(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def removeDuplicates(self, s: str) -> str:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "char * removeDuplicates(char * s){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public string RemoveDuplicates(string s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar removeDuplicates = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @return {String}\ndef remove_duplicates(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func removeDuplicates(_ s: String) -> String {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func removeDuplicates(s string) string {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def removeDuplicates(s: String): String = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun removeDuplicates(s: String): String {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn remove_duplicates(s: String) -> String {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function removeDuplicates($s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function removeDuplicates(s: string): string {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (remove-duplicates s)\n  (-> string? string?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec remove_duplicates(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nremove_duplicates(S) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec remove_duplicates(s :: String.t) :: String.t\n  def remove_duplicates(s) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  String removeDuplicates(String s) {\n\n  }\n}"
            }
        ],
        "testcase": "\"abbaca\"",
        "testable": true,
        "templateMeta": {
            "name": "removeDuplicates",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                }
            ],
            "return": {
                "type": "string"
            }
        }
    },
    {
        "id": 98,
        "fid": 98,
        "name": "Validate Binary Search Tree",
        "slug": "validate-binary-search-tree",
        "link": "https://leetcode.com/problems/validate-binary-search-tree/description/",
        "percent": 31.882082363508395,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "amazon",
            "bloomberg",
            "facebook",
            "microsoft"
        ],
        "tags": [
            "tree",
            "depth-first-search"
        ],
        "totalAC": "1.8M",
        "totalSubmit": "5.7M",
        "likes": 13763,
        "dislikes": 1129,
        "desc": "<p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>\n\n<p>A <strong>valid BST</strong> is defined as follows:</p>\n\n<ul>\n\t<li>The left <span data-keyword=\"subtree\">subtree</span> of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n<pre>\n<strong>Input:</strong> root = [5,1,4,null,null,3,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The root node&#39;s value is 5 but its right child&#39;s value is 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool isValidBST(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsValidBST(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Boolean}\ndef is_valid_bst(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isValidBST(_ root: TreeNode?) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isValidBST(root *TreeNode) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isValidBST(root: TreeNode): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isValidBST(root: TreeNode?): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function isValidBST($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isValidBST(root: TreeNode | null): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (is-valid-bst root)\n  (-> (or/c tree-node? #f) boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_valid_bst(Root :: #tree_node{} | null) -> boolean().\nis_valid_bst(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_valid_bst(root :: TreeNode.t | nil) :: boolean\n  def is_valid_bst(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool isValidBST(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[2,1,3]",
        "testable": true,
        "templateMeta": {
            "name": "isValidBST",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 654,
        "fid": 654,
        "name": "Maximum Binary Tree",
        "slug": "maximum-binary-tree",
        "link": "https://leetcode.com/problems/maximum-binary-tree/description/",
        "percent": 84.64541873785238,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "microsoft"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "246.1K",
        "totalSubmit": "290.7K",
        "likes": 4464,
        "dislikes": 311,
        "desc": "<p>You are given an integer array <code>nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code>nums</code> using the following algorithm:</p>\n\n<ol>\n\t<li>Create a root node whose value is the maximum value in <code>nums</code>.</li>\n\t<li>Recursively build the left subtree on the <strong>subarray prefix</strong> to the <strong>left</strong> of the maximum value.</li>\n\t<li>Recursively build the right subtree on the <strong>subarray suffix</strong> to the <strong>right</strong> of the maximum value.</li>\n</ol>\n\n<p>Return <em>the <strong>maximum binary tree</strong> built from </em><code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg\" style=\"width: 302px; height: 421px;\" />\n<pre>\n<strong>Input:</strong> nums = [3,2,1,6,0,5]\n<strong>Output:</strong> [6,3,5,null,2,0,null,null,1]\n<strong>Explanation:</strong> The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg\" style=\"width: 182px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> [3,null,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>All integers in <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def constructMaximumBinaryTree(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode ConstructMaximumBinaryTree(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar constructMaximumBinaryTree = function(nums) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {Integer[]} nums\n# @return {TreeNode}\ndef construct_maximum_binary_tree(nums)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func constructMaximumBinaryTree(_ nums: [Int]) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc constructMaximumBinaryTree(nums []int) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def constructMaximumBinaryTree(nums: Array[Int]): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun constructMaximumBinaryTree(nums: IntArray): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn construct_maximum_binary_tree(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return TreeNode\n     */\n    function constructMaximumBinaryTree($nums) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction constructMaximumBinaryTree(nums: number[]): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (construct-maximum-binary-tree nums)\n  (-> (listof exact-integer?) (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec construct_maximum_binary_tree(Nums :: [integer()]) -> #tree_node{} | null.\nconstruct_maximum_binary_tree(Nums) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec construct_maximum_binary_tree(nums :: [integer]) :: TreeNode.t | nil\n  def construct_maximum_binary_tree(nums) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? constructMaximumBinaryTree(List<int> nums) {\n\n  }\n}"
            }
        ],
        "testcase": "[3,2,1,6,0,5]",
        "testable": true,
        "templateMeta": {
            "name": "constructMaximumBinaryTree",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "TreeNode",
                "dealloc": true
            }
        }
    },
    {
        "id": 1044,
        "fid": 1002,
        "name": "Find Common Characters",
        "slug": "find-common-characters",
        "link": "https://leetcode.com/problems/find-common-characters/description/",
        "percent": 68.41764412479284,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "array",
            "hash-table"
        ],
        "totalAC": "170.1K",
        "totalSubmit": "248.6K",
        "likes": 2852,
        "dislikes": 234,
        "desc": "<p>Given a string array <code>words</code>, return <em>an array of all characters that show up in all strings within the </em><code>words</code><em> (including duplicates)</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> words = [\"bella\",\"label\",\"roller\"]\n<strong>Output:</strong> [\"e\",\"l\",\"l\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> words = [\"cool\",\"lock\",\"cook\"]\n<strong>Output:</strong> [\"c\",\"o\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<string> commonChars(vector<string>& words) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public List<String> commonChars(String[] words) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def commonChars(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def commonChars(self, words: List[str]) -> List[str]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** commonChars(char ** words, int wordsSize, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public IList<string> CommonChars(string[] words) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string[]} words\n * @return {string[]}\n */\nvar commonChars = function(words) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String[]} words\n# @return {String[]}\ndef common_chars(words)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func commonChars(_ words: [String]) -> [String] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func commonChars(words []string) []string {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def commonChars(words: Array[String]): List[String] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun commonChars(words: Array<String>): List<String> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn common_chars(words: Vec<String>) -> Vec<String> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return String[]\n     */\n    function commonChars($words) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function commonChars(words: string[]): string[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (common-chars words)\n  (-> (listof string?) (listof string?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec common_chars(Words :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\ncommon_chars(Words) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec common_chars(words :: [String.t]) :: [String.t]\n  def common_chars(words) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<String> commonChars(List<String> words) {\n\n  }\n}"
            }
        ],
        "testcase": "[\"bella\",\"label\",\"roller\"]",
        "testable": true,
        "templateMeta": {
            "name": "commonChars",
            "params": [
                {
                    "name": "words",
                    "type": "string[]"
                }
            ],
            "return": {
                "type": "list<string>"
            }
        }
    },
    {
        "id": 538,
        "fid": 538,
        "name": "Convert BST to Greater Tree",
        "slug": "convert-bst-to-greater-tree",
        "link": "https://leetcode.com/problems/convert-bst-to-greater-tree/description/",
        "percent": 67.6111024884888,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "amazon"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "261.4K",
        "totalSubmit": "386.6K",
        "likes": 4676,
        "dislikes": 167,
        "desc": "<p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>\n\n<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>\n\n<ul>\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/02/tree.png\" style=\"width: 500px; height: 341px;\" />\n<pre>\n<strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0,null,1]\n<strong>Output:</strong> [1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>All the values in the tree are <strong>unique</strong>.</li>\n\t<li><code>root</code> is guaranteed to be a valid binary search tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 1038: <a href=\"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\" target=\"_blank\">https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/</a></p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* convertBST(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode convertBST(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def convertBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* convertBST(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode ConvertBST(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar convertBST = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {TreeNode}\ndef convert_bst(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func convertBST(_ root: TreeNode?) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc convertBST(root *TreeNode) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def convertBST(root: TreeNode): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun convertBST(root: TreeNode?): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn convert_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return TreeNode\n     */\n    function convertBST($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction convertBST(root: TreeNode | null): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (convert-bst root)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec convert_bst(Root :: #tree_node{} | null) -> #tree_node{} | null.\nconvert_bst(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec convert_bst(root :: TreeNode.t | nil) :: TreeNode.t | nil\n  def convert_bst(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? convertBST(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]",
        "testable": true,
        "templateMeta": {
            "name": "convertBST",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "TreeNode"
            },
            "manual": false
        }
    },
    {
        "id": 501,
        "fid": 501,
        "name": "Find Mode in Binary Search Tree",
        "slug": "find-mode-in-binary-search-tree",
        "link": "https://leetcode.com/problems/find-mode-in-binary-search-tree/description/",
        "percent": 49.030142263736735,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "google"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "182.2K",
        "totalSubmit": "371.7K",
        "likes": 2737,
        "dislikes": 632,
        "desc": "<p>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a href=\"https://en.wikipedia.org/wiki/Mode_(statistics)\" target=\"_blank\">mode(s)</a> (i.e., the most frequently occurred element) in it</em>.</p>\n\n<p>If the tree has more than one mode, return them in <strong>any order</strong>.</p>\n\n<p>Assume a BST is defined as follows:</p>\n\n<ul>\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg\" style=\"width: 142px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,2]\n<strong>Output:</strong> [2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int[] findMode(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findMode(struct TreeNode* root, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int[] FindMode(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar findMode = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer[]}\ndef find_mode(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func findMode(_ root: TreeNode?) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findMode(root *TreeNode) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def findMode(root: TreeNode): Array[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun findMode(root: TreeNode?): IntArray {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn find_mode(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function findMode($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findMode(root: TreeNode | null): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (find-mode root)\n  (-> (or/c tree-node? #f) (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec find_mode(Root :: #tree_node{} | null) -> [integer()].\nfind_mode(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec find_mode(root :: TreeNode.t | nil) :: [integer]\n  def find_mode(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<int> findMode(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,null,2,2]",
        "testable": true,
        "templateMeta": {
            "name": "findMode",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "integer[]"
            }
        }
    },
    {
        "id": 45,
        "fid": 45,
        "name": "Jump Game II",
        "slug": "jump-game-ii",
        "link": "https://leetcode.com/problems/jump-game-ii/description/",
        "percent": 38.79433330347631,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "array",
            "greedy"
        ],
        "totalAC": "842.5K",
        "totalSubmit": "2.1M",
        "likes": 11698,
        "dislikes": 405,
        "desc": "<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.</p>\n\n<p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= j &lt;= nums[i]</code> and</li>\n\t<li><code>i + j &lt; n</code></li>\n</ul>\n\n<p>Return <em>the minimum number of jumps to reach </em><code>nums[n - 1]</code>. The test cases are generated such that you can reach <code>nums[n - 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,0,1,4]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>It&#39;s guaranteed that you can reach <code>nums[n - 1]</code>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int jump(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int jump(int* nums, int numsSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int Jump(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @return {Integer}\ndef jump(nums)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func jump(_ nums: [Int]) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func jump(nums []int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def jump(nums: Array[Int]): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun jump(nums: IntArray): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn jump(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function jump($nums) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function jump(nums: number[]): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (jump nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec jump(Nums :: [integer()]) -> integer().\njump(Nums) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec jump(nums :: [integer]) :: integer\n  def jump(nums) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int jump(List<int> nums) {\n\n  }\n}"
            }
        ],
        "testcase": "[2,3,1,1,4]",
        "testable": true,
        "templateMeta": {
            "name": "jump",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 792,
        "fid": 704,
        "name": "Binary Search",
        "slug": "binary-search",
        "link": "https://leetcode.com/problems/binary-search/description/",
        "percent": 55.2855167754256,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "binary-search"
        ],
        "totalAC": "1.5M",
        "totalSubmit": "2.7M",
        "likes": 7905,
        "dislikes": 171,
        "desc": "<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 9\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> 9 exists in nums and its index is 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> 2 does not exist in nums so return -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt; nums[i], target &lt; 10<sup>4</sup></code></li>\n\t<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted in ascending order.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int search(int* nums, int numsSize, int target){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int Search(int[] nums, int target) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search(nums, target)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func search(nums []int, target int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def search(nums: Array[Int], target: Int): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun search(nums: IntArray, target: Int): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function search($nums, $target) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function search(nums: number[], target: number): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (search nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec search(Nums :: [integer()], Target :: integer()) -> integer().\nsearch(Nums, Target) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) :: integer\n  def search(nums, target) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int search(List<int> nums, int target) {\n\n  }\n}"
            }
        ],
        "testcase": "[-1,0,3,5,9,12]\n9",
        "testable": true,
        "templateMeta": {
            "name": "search",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                },
                {
                    "name": "target",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 266,
        "fid": 266,
        "name": "Palindrome Permutation",
        "slug": "palindrome-permutation",
        "link": "https://leetcode.com/problems/palindrome-permutation/description/",
        "percent": 65.98207672937343,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "bloomberg",
            "google",
            "uber"
        ],
        "tags": [
            "hash-table"
        ],
        "totalAC": "178.2K",
        "totalSubmit": "270K",
        "likes": 950,
        "dislikes": 67,
        "desc": "<p>Given a string <code>s</code>, return <code>true</code> <em>if a permutation of the string could form a </em><span data-keyword=\"palindrome-string\"><em><strong>palindrome</strong></em></span><em> and </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;code&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;carerac&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5000</code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    bool canPermutePalindrome(string s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public boolean canPermutePalindrome(String s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def canPermutePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def canPermutePalindrome(self, s: str) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "bool canPermutePalindrome(char * s){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public bool CanPermutePalindrome(string s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar canPermutePalindrome = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @return {Boolean}\ndef can_permute_palindrome(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func canPermutePalindrome(_ s: String) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func canPermutePalindrome(s string) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def canPermutePalindrome(s: String): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun canPermutePalindrome(s: String): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn can_permute_palindrome(s: String) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function canPermutePalindrome($s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function canPermutePalindrome(s: string): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (can-permute-palindrome s)\n  (-> string? boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec can_permute_palindrome(S :: unicode:unicode_binary()) -> boolean().\ncan_permute_palindrome(S) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec can_permute_palindrome(s :: String.t) :: boolean\n  def can_permute_palindrome(s) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  bool canPermutePalindrome(String s) {\n\n  }\n}"
            }
        ],
        "testcase": "\"code\"",
        "testable": true,
        "templateMeta": {
            "name": "canPermutePalindrome",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 383,
        "fid": 383,
        "name": "Ransom Note",
        "slug": "ransom-note",
        "link": "https://leetcode.com/problems/ransom-note/description/",
        "percent": 57.93826346439157,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "apple"
        ],
        "tags": [
            "string"
        ],
        "totalAC": "688.9K",
        "totalSubmit": "1.2M",
        "likes": 3595,
        "dislikes": 398,
        "desc": "<p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code><em> if </em><code>ransomNote</code><em> can be constructed by using the letters from </em><code>magazine</code><em> and </em><code>false</code><em> otherwise</em>.</p>\n\n<p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> ransomNote = \"a\", magazine = \"b\"\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> ransomNote = \"aa\", magazine = \"ab\"\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> ransomNote = \"aa\", magazine = \"aab\"\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>ransomNote</code> and <code>magazine</code> consist of lowercase English letters.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def canConstruct(self, ransomNote, magazine):\n        \"\"\"\n        :type ransomNote: str\n        :type magazine: str\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "bool canConstruct(char * ransomNote, char * magazine){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public bool CanConstruct(string ransomNote, string magazine) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} ransomNote\n * @param {string} magazine\n * @return {boolean}\n */\nvar canConstruct = function(ransomNote, magazine) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} ransom_note\n# @param {String} magazine\n# @return {Boolean}\ndef can_construct(ransom_note, magazine)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func canConstruct(_ ransomNote: String, _ magazine: String) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func canConstruct(ransomNote string, magazine string) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def canConstruct(ransomNote: String, magazine: String): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun canConstruct(ransomNote: String, magazine: String): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn can_construct(ransom_note: String, magazine: String) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $ransomNote\n     * @param String $magazine\n     * @return Boolean\n     */\n    function canConstruct($ransomNote, $magazine) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function canConstruct(ransomNote: string, magazine: string): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (can-construct ransomNote magazine)\n  (-> string? string? boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec can_construct(RansomNote :: unicode:unicode_binary(), Magazine :: unicode:unicode_binary()) -> boolean().\ncan_construct(RansomNote, Magazine) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec can_construct(ransom_note :: String.t, magazine :: String.t) :: boolean\n  def can_construct(ransom_note, magazine) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  bool canConstruct(String ransomNote, String magazine) {\n\n  }\n}"
            }
        ],
        "testcase": "\"a\"\n\"b\"",
        "testable": true,
        "templateMeta": {
            "name": "canConstruct",
            "params": [
                {
                    "name": "ransomNote",
                    "type": "string"
                },
                {
                    "name": "magazine",
                    "type": "string"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 100,
        "fid": 100,
        "name": "Same Tree",
        "slug": "same-tree",
        "link": "https://leetcode.com/problems/same-tree/description/",
        "percent": 57.804853795165286,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "bloomberg"
        ],
        "tags": [
            "tree",
            "depth-first-search"
        ],
        "totalAC": "1.4M",
        "totalSubmit": "2.5M",
        "likes": 8768,
        "dislikes": 179,
        "desc": "<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>\n\n<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2,3], q = [1,2,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2], q = [1,null,2]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2,1], q = [1,1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} p\n# @param {TreeNode} q\n# @return {Boolean}\ndef is_same_tree(p, q)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return Boolean\n     */\n    function isSameTree($p, $q) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (is-same-tree p q)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f) boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_same_tree(P :: #tree_node{} | null, Q :: #tree_node{} | null) -> boolean().\nis_same_tree(P, Q) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\n  def is_same_tree(p, q) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool isSameTree(TreeNode? p, TreeNode? q) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,3]\n[1,2,3]",
        "testable": true,
        "templateMeta": {
            "name": "isSameTree",
            "params": [
                {
                    "name": "p",
                    "type": "TreeNode"
                },
                {
                    "name": "q",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 232,
        "fid": 232,
        "name": "Implement Queue using Stacks",
        "slug": "implement-queue-using-stacks",
        "link": "https://leetcode.com/problems/implement-queue-using-stacks/description/",
        "percent": 62.83015528001449,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "bloomberg",
            "microsoft"
        ],
        "tags": [
            "stack",
            "design"
        ],
        "totalAC": "610.5K",
        "totalSubmit": "971.7K",
        "likes": 5535,
        "dislikes": 328,
        "desc": "<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyQueue</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>\n\t<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>\n\t<li><code>int peek()</code> Returns the element at the front of the queue.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><strong>Notes:</strong></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 1, 1, false]\n\n<strong>Explanation</strong>\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code>&nbsp;calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the queue such that each operation is <strong><a href=\"https://en.wikipedia.org/wiki/Amortized_analysis\" target=\"_blank\">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class MyQueue {\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        \n    }\n    \n    int pop() {\n        \n    }\n    \n    int peek() {\n        \n    }\n    \n    bool empty() {\n        \n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class MyQueue {\n\n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n    \n    public int peek() {\n        \n    }\n    \n    public boolean empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class MyQueue(object):\n\n    def __init__(self):\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()"
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class MyQueue:\n\n    def __init__(self):\n        \n\n    def push(self, x: int) -> None:\n        \n\n    def pop(self) -> int:\n        \n\n    def peek(self) -> int:\n        \n\n    def empty(self) -> bool:\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()"
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "\n\n\ntypedef struct {\n    \n} MyQueue;\n\n\nMyQueue* myQueueCreate() {\n    \n}\n\nvoid myQueuePush(MyQueue* obj, int x) {\n  \n}\n\nint myQueuePop(MyQueue* obj) {\n  \n}\n\nint myQueuePeek(MyQueue* obj) {\n  \n}\n\nbool myQueueEmpty(MyQueue* obj) {\n  \n}\n\nvoid myQueueFree(MyQueue* obj) {\n    \n}\n\n/**\n * Your MyQueue struct will be instantiated and called as such:\n * MyQueue* obj = myQueueCreate();\n * myQueuePush(obj, x);\n \n * int param_2 = myQueuePop(obj);\n \n * int param_3 = myQueuePeek(obj);\n \n * bool param_4 = myQueueEmpty(obj);\n \n * myQueueFree(obj);\n*/"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class MyQueue {\n\n    public MyQueue() {\n        \n    }\n    \n    public void Push(int x) {\n        \n    }\n    \n    public int Pop() {\n        \n    }\n    \n    public int Peek() {\n        \n    }\n    \n    public bool Empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Peek();\n * bool param_4 = obj.Empty();\n */"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "\nvar MyQueue = function() {\n    \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    \n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "class MyQueue\n    def initialize()\n        \n    end\n\n\n=begin\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def peek()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def empty()\n        \n    end\n\n\nend\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue.new()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "\nclass MyQueue {\n\n    init() {\n        \n    }\n    \n    func push(_ x: Int) {\n        \n    }\n    \n    func pop() -> Int {\n        \n    }\n    \n    func peek() -> Int {\n        \n    }\n    \n    func empty() -> Bool {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * let obj = MyQueue()\n * obj.push(x)\n * let ret_2: Int = obj.pop()\n * let ret_3: Int = obj.peek()\n * let ret_4: Bool = obj.empty()\n */"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "type MyQueue struct {\n    \n}\n\n\nfunc Constructor() MyQueue {\n    \n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n    \n}\n\n\nfunc (this *MyQueue) Pop() int {\n    \n}\n\n\nfunc (this *MyQueue) Peek() int {\n    \n}\n\n\nfunc (this *MyQueue) Empty() bool {\n    \n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "class MyQueue() {\n\n    def push(x: Int) {\n        \n    }\n\n    def pop(): Int = {\n        \n    }\n\n    def peek(): Int = {\n        \n    }\n\n    def empty(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class MyQueue() {\n\n    fun push(x: Int) {\n        \n    }\n\n    fun pop(): Int {\n        \n    }\n\n    fun peek(): Int {\n        \n    }\n\n    fun empty(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "struct MyQueue {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyQueue {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn push(&self, x: i32) {\n        \n    }\n    \n    fn pop(&self) -> i32 {\n        \n    }\n    \n    fn peek(&self) -> i32 {\n        \n    }\n    \n    fn empty(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * let obj = MyQueue::new();\n * obj.push(x);\n * let ret_2: i32 = obj.pop();\n * let ret_3: i32 = obj.peek();\n * let ret_4: bool = obj.empty();\n */"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class MyQueue {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function peek() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * $obj = MyQueue();\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $ret_3 = $obj->peek();\n * $ret_4 = $obj->empty();\n */"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "class MyQueue {\n    constructor() {\n\n    }\n\n    push(x: number): void {\n\n    }\n\n    pop(): number {\n\n    }\n\n    peek(): number {\n\n    }\n\n    empty(): boolean {\n\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define my-queue%\n  (class object%\n    (super-new)\n    (init-field)\n    \n    ; push : exact-integer? -> void?\n    (define/public (push x)\n\n      )\n    ; pop : -> exact-integer?\n    (define/public (pop)\n\n      )\n    ; peek : -> exact-integer?\n    (define/public (peek)\n\n      )\n    ; empty : -> boolean?\n    (define/public (empty)\n\n      )))\n\n;; Your my-queue% object will be instantiated and called as such:\n;; (define obj (new my-queue%))\n;; (send obj push x)\n;; (define param_2 (send obj pop))\n;; (define param_3 (send obj peek))\n;; (define param_4 (send obj empty))"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec my_queue_init_() -> any().\nmy_queue_init_() ->\n  .\n\n-spec my_queue_push(X :: integer()) -> any().\nmy_queue_push(X) ->\n  .\n\n-spec my_queue_pop() -> integer().\nmy_queue_pop() ->\n  .\n\n-spec my_queue_peek() -> integer().\nmy_queue_peek() ->\n  .\n\n-spec my_queue_empty() -> boolean().\nmy_queue_empty() ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_queue_init_(),\n%% my_queue_push(X),\n%% Param_2 = my_queue_pop(),\n%% Param_3 = my_queue_peek(),\n%% Param_4 = my_queue_empty(),\n\n%% my_queue_init_ will be called before every test case, in which you can do some necessary initializations."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule MyQueue do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec push(x :: integer) :: any\n  def push(x) do\n\n  end\n\n  @spec pop() :: integer\n  def pop() do\n\n  end\n\n  @spec peek() :: integer\n  def peek() do\n\n  end\n\n  @spec empty() :: boolean\n  def empty() do\n\n  end\nend\n\n# Your functions will be called as such:\n# MyQueue.init_()\n# MyQueue.push(x)\n# param_2 = MyQueue.pop()\n# param_3 = MyQueue.peek()\n# param_4 = MyQueue.empty()\n\n# MyQueue.init_ will be called before every test case, in which you can do some necessary initializations."
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class MyQueue {\n\n  MyQueue() {\n\n  }\n  \n  void push(int x) {\n\n  }\n  \n  int pop() {\n\n  }\n  \n  int peek() {\n\n  }\n  \n  bool empty() {\n\n  }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = MyQueue();\n * obj.push(x);\n * int param2 = obj.pop();\n * int param3 = obj.peek();\n * bool param4 = obj.empty();\n */"
            }
        ],
        "testcase": "[\"MyQueue\",\"push\",\"push\",\"peek\",\"pop\",\"empty\"]\n[[],[1],[2],[],[],[]]",
        "testable": true,
        "templateMeta": {
            "classname": "MyQueue",
            "constructor": {
                "params": []
            },
            "methods": [
                {
                    "params": [
                        {
                            "type": "integer",
                            "name": "x"
                        }
                    ],
                    "return": {
                        "type": "void"
                    },
                    "name": "push"
                },
                {
                    "params": [],
                    "return": {
                        "type": "integer"
                    },
                    "name": "pop"
                },
                {
                    "params": [],
                    "return": {
                        "type": "integer"
                    },
                    "name": "peek"
                },
                {
                    "params": [],
                    "return": {
                        "type": "boolean"
                    },
                    "name": "empty"
                }
            ],
            "return": {
                "type": "boolean"
            },
            "systemdesign": true
        }
    },
    {
        "id": 94,
        "fid": 94,
        "name": "Binary Tree Inorder Traversal",
        "slug": "binary-tree-inorder-traversal",
        "link": "https://leetcode.com/problems/binary-tree-inorder-traversal/description/",
        "percent": 73.47345713202927,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "microsoft"
        ],
        "tags": [
            "hash-table",
            "stack",
            "tree"
        ],
        "totalAC": "1.9M",
        "totalSubmit": "2.6M",
        "likes": 10722,
        "dislikes": 516,
        "desc": "<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 125px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,3,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> InorderTraversal(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer[]}\ndef inorder_traversal(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc inorderTraversal(root *TreeNode) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def inorderTraversal(root: TreeNode): List[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun inorderTraversal(root: TreeNode?): List<Int> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function inorderTraversal($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction inorderTraversal(root: TreeNode | null): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (inorder-traversal root)\n  (-> (or/c tree-node? #f) (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec inorder_traversal(Root :: #tree_node{} | null) -> [integer()].\ninorder_traversal(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec inorder_traversal(root :: TreeNode.t | nil) :: [integer]\n  def inorder_traversal(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<int> inorderTraversal(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,null,2,3]",
        "testable": true,
        "templateMeta": {
            "name": "inorderTraversal",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "list<integer>",
                "dealloc": true
            }
        }
    },
    {
        "id": 226,
        "fid": 226,
        "name": "Invert Binary Tree",
        "slug": "invert-binary-tree",
        "link": "https://leetcode.com/problems/invert-binary-tree/description/",
        "percent": 73.79008913291047,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "tree"
        ],
        "totalAC": "1.4M",
        "totalSubmit": "1.9M",
        "likes": 10862,
        "dislikes": 153,
        "desc": "<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\" style=\"width: 500px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3,6,9]\n<strong>Output:</strong> [4,7,2,9,6,3,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\" style=\"width: 500px; height: 120px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,3,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* invertTree(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode InvertTree(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {TreeNode}\ndef invert_tree(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func invertTree(_ root: TreeNode?) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc invertTree(root *TreeNode) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def invertTree(root: TreeNode): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun invertTree(root: TreeNode?): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return TreeNode\n     */\n    function invertTree($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction invertTree(root: TreeNode | null): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (invert-tree root)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec invert_tree(Root :: #tree_node{} | null) -> #tree_node{} | null.\ninvert_tree(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec invert_tree(root :: TreeNode.t | nil) :: TreeNode.t | nil\n  def invert_tree(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? invertTree(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[4,2,7,1,3,6,9]",
        "testable": true,
        "templateMeta": {
            "name": "invertTree",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "TreeNode"
            }
        }
    },
    {
        "id": 785,
        "fid": 772,
        "name": "Basic Calculator III",
        "slug": "basic-calculator-iii",
        "link": "https://leetcode.com/problems/basic-calculator-iii/description/",
        "percent": 48.71798595278548,
        "level": "Hard",
        "category": "algorithms",
        "tags": [
            "string",
            "stack"
        ],
        "totalAC": "100.9K",
        "totalSubmit": "207K",
        "likes": 998,
        "dislikes": 266,
        "desc": "<p>Implement a basic calculator to evaluate a simple expression string.</p>\n\n<p>The expression string contains only non-negative integers, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code> operators, and open <code>&#39;(&#39;</code> and closing parentheses <code>&#39;)&#39;</code>. The integer division should <strong>truncate toward zero</strong>.</p>\n\n<p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.</p>\n\n<p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1+1&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;6-4/2&quot;\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2*(5+5*2)/3+(6/2+8)&quot;\n<strong>Output:</strong> 21\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;(&#39;</code>,&nbsp;and&nbsp;<code>&#39;)&#39;</code>.</li>\n\t<li><code>s</code> is a <strong>valid</strong> expression.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int calculate(string s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int calculate(String s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def calculate(self, s: str) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int calculate(char * s){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int Calculate(string s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar calculate = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @return {Integer}\ndef calculate(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func calculate(_ s: String) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func calculate(s string) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def calculate(s: String): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun calculate(s: String): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn calculate(s: String) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function calculate($s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function calculate(s: string): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (calculate s)\n  (-> string? exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec calculate(S :: unicode:unicode_binary()) -> integer().\ncalculate(S) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec calculate(s :: String.t) :: integer\n  def calculate(s) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int calculate(String s) {\n\n  }\n}"
            }
        ],
        "testcase": "\"1+1\"",
        "testable": true,
        "templateMeta": {
            "name": "calculate",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 102,
        "fid": 102,
        "name": "Binary Tree Level Order Traversal",
        "slug": "binary-tree-level-order-traversal",
        "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/description/",
        "percent": 63.875107292359864,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "amazon",
            "apple",
            "bloomberg",
            "facebook",
            "linkedin",
            "microsoft"
        ],
        "tags": [
            "tree",
            "breadth-first-search"
        ],
        "totalAC": "1.7M",
        "totalSubmit": "2.6M",
        "likes": 12202,
        "dislikes": 240,
        "desc": "<p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[9,20],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<IList<int>> LevelOrder(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer[][]}\ndef level_order(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func levelOrder(_ root: TreeNode?) -> [[Int]] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrder(root *TreeNode) [][]int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def levelOrder(root: TreeNode): List[List[Int]] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun levelOrder(root: TreeNode?): List<List<Int>> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[][]\n     */\n    function levelOrder($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction levelOrder(root: TreeNode | null): number[][] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (level-order root)\n  (-> (or/c tree-node? #f) (listof (listof exact-integer?)))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec level_order(Root :: #tree_node{} | null) -> [[integer()]].\nlevel_order(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec level_order(root :: TreeNode.t | nil) :: [[integer]]\n  def level_order(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<List<int>> levelOrder(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[3,9,20,null,null,15,7]",
        "testable": true,
        "templateMeta": {
            "name": "levelOrder",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "list<list<integer>>",
                "dealloc": true
            }
        }
    },
    {
        "id": 112,
        "fid": 112,
        "name": "Path Sum",
        "slug": "path-sum",
        "link": "https://leetcode.com/problems/path-sum/description/",
        "percent": 47.979750411042914,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "microsoft"
        ],
        "tags": [
            "tree",
            "depth-first-search"
        ],
        "totalAC": "1.1M",
        "totalSubmit": "2.3M",
        "likes": 7811,
        "dislikes": 912,
        "desc": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There two root-to-leaf paths in the tree:\n(1 --&gt; 2): The sum is 3.\n(1 --&gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], targetSum = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool hasPathSum(struct TreeNode* root, int targetSum){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool HasPathSum(TreeNode root, int targetSum) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function(root, targetSum) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer} target_sum\n# @return {Boolean}\ndef has_path_sum(root, target_sum)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def hasPathSum(root: TreeNode, targetSum: Int): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun hasPathSum(root: TreeNode?, targetSum: Int): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $targetSum\n     * @return Boolean\n     */\n    function hasPathSum($root, $targetSum) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction hasPathSum(root: TreeNode | null, targetSum: number): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (has-path-sum root targetSum)\n  (-> (or/c tree-node? #f) exact-integer? boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec has_path_sum(Root :: #tree_node{} | null, TargetSum :: integer()) -> boolean().\nhas_path_sum(Root, TargetSum) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec has_path_sum(root :: TreeNode.t | nil, target_sum :: integer) :: boolean\n  def has_path_sum(root, target_sum) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool hasPathSum(TreeNode? root, int targetSum) {\n\n  }\n}"
            }
        ],
        "testcase": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\n22",
        "testable": true,
        "templateMeta": {
            "name": "hasPathSum",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                },
                {
                    "name": "targetSum",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 224,
        "fid": 224,
        "name": "Basic Calculator",
        "slug": "basic-calculator",
        "link": "https://leetcode.com/problems/basic-calculator/description/",
        "percent": 42.353603344896506,
        "level": "Hard",
        "category": "algorithms",
        "companies": [
            "google"
        ],
        "tags": [
            "math",
            "stack"
        ],
        "totalAC": "369.5K",
        "totalSubmit": "872.2K",
        "likes": 5187,
        "dislikes": 386,
        "desc": "<p>Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</p>\n\n<p><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1 + 1&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; 2-1 + 2 &quot;\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(1+(4+5+2)-3)+(6+8)&quot;\n<strong>Output:</strong> 23\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, and <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> represents a valid expression.</li>\n\t<li><code>&#39;+&#39;</code> is <strong>not</strong> used as a unary operation (i.e., <code>&quot;+1&quot;</code> and <code>&quot;+(2 + 3)&quot;</code> is invalid).</li>\n\t<li><code>&#39;-&#39;</code> could be used as a unary operation (i.e., <code>&quot;-1&quot;</code> and <code>&quot;-(2 + 3)&quot;</code> is valid).</li>\n\t<li>There will be no two consecutive operators in the input.</li>\n\t<li>Every number and running calculation will fit in a signed 32-bit integer.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int calculate(string s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int calculate(String s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def calculate(self, s: str) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int calculate(char * s){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int Calculate(string s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar calculate = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @return {Integer}\ndef calculate(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func calculate(_ s: String) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func calculate(s string) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def calculate(s: String): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun calculate(s: String): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn calculate(s: String) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function calculate($s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function calculate(s: string): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (calculate s)\n  (-> string? exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec calculate(S :: unicode:unicode_binary()) -> integer().\ncalculate(S) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec calculate(s :: String.t) :: integer\n  def calculate(s) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int calculate(String s) {\n\n  }\n}"
            }
        ],
        "testcase": "\"1 + 1\"",
        "testable": true,
        "templateMeta": {
            "name": "calculate",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 459,
        "fid": 459,
        "name": "Repeated Substring Pattern",
        "slug": "repeated-substring-pattern",
        "link": "https://leetcode.com/problems/repeated-substring-pattern/description/",
        "percent": 43.69899414595426,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "amazon",
            "google"
        ],
        "tags": [
            "string"
        ],
        "totalAC": "281.9K",
        "totalSubmit": "645.1K",
        "likes": 4099,
        "dislikes": 369,
        "desc": "<p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abab&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;ab&quot; twice.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcabcabc&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "bool repeatedSubstringPattern(char * s){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public bool RepeatedSubstringPattern(string s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar repeatedSubstringPattern = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @return {Boolean}\ndef repeated_substring_pattern(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func repeatedSubstringPattern(_ s: String) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func repeatedSubstringPattern(s string) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def repeatedSubstringPattern(s: String): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun repeatedSubstringPattern(s: String): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn repeated_substring_pattern(s: String) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function repeatedSubstringPattern($s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function repeatedSubstringPattern(s: string): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (repeated-substring-pattern s)\n  (-> string? boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec repeated_substring_pattern(S :: unicode:unicode_binary()) -> boolean().\nrepeated_substring_pattern(S) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec repeated_substring_pattern(s :: String.t) :: boolean\n  def repeated_substring_pattern(s) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  bool repeatedSubstringPattern(String s) {\n\n  }\n}"
            }
        ],
        "testcase": "\"abab\"",
        "testable": true,
        "templateMeta": {
            "name": "repeatedSubstringPattern",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 144,
        "fid": 144,
        "name": "Binary Tree Preorder Traversal",
        "slug": "binary-tree-preorder-traversal",
        "link": "https://leetcode.com/problems/binary-tree-preorder-traversal/description/",
        "percent": 66.40100492903883,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "stack",
            "tree"
        ],
        "totalAC": "1.3M",
        "totalSubmit": "1.9M",
        "likes": 6376,
        "dislikes": 171,
        "desc": "<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 125px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> PreorderTraversal(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer[]}\ndef preorder_traversal(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc preorderTraversal(root *TreeNode) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def preorderTraversal(root: TreeNode): List[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun preorderTraversal(root: TreeNode?): List<Int> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn preorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function preorderTraversal($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction preorderTraversal(root: TreeNode | null): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (preorder-traversal root)\n  (-> (or/c tree-node? #f) (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec preorder_traversal(Root :: #tree_node{} | null) -> [integer()].\npreorder_traversal(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec preorder_traversal(root :: TreeNode.t | nil) :: [integer]\n  def preorder_traversal(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<int> preorderTraversal(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,null,2,3]",
        "testable": true,
        "templateMeta": {
            "name": "preorderTraversal",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "list<integer>",
                "dealloc": true
            }
        }
    },
    {
        "id": 450,
        "fid": 450,
        "name": "Delete Node in a BST",
        "slug": "delete-node-in-a-bst",
        "link": "https://leetcode.com/problems/delete-node-in-a-bst/description/",
        "percent": 50.13118215388179,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "uber"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "337.6K",
        "totalSubmit": "673.5K",
        "likes": 6891,
        "dislikes": 174,
        "desc": "<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p>\n\n<p>Basically, the deletion can be divided into two stages:</p>\n\n<ol>\n\t<li>Search for a node to remove.</li>\n\t<li>If the node is found, delete the node.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg\" style=\"width: 800px; height: 214px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 3\n<strong>Output:</strong> [5,4,6,2,null,null,7]\n<strong>Explanation:</strong> Given key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is [5,4,6,2,null,null,7], shown in the above BST.\nPlease notice that another valid answer is [5,2,6,null,4,null,7] and it&#39;s also accepted.\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg\" style=\"width: 350px; height: 255px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 0\n<strong>Output:</strong> [5,3,6,2,4,null,7]\n<strong>Explanation:</strong> The tree does not contain a node with value = 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], key = 0\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>Each node has a <strong>unique</strong> value.</li>\n\t<li><code>root</code> is a valid binary search tree.</li>\n\t<li><code>-10<sup>5</sup> &lt;= key &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it with time complexity <code>O(height of tree)</code>?</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def deleteNode(self, root, key):\n        \"\"\"\n        :type root: TreeNode\n        :type key: int\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* deleteNode(struct TreeNode* root, int key){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode DeleteNode(TreeNode root, int key) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nvar deleteNode = function(root, key) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer} key\n# @return {TreeNode}\ndef delete_node(root, key)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func deleteNode(_ root: TreeNode?, _ key: Int) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def deleteNode(root: TreeNode, key: Int): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun deleteNode(root: TreeNode?, key: Int): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn delete_node(root: Option<Rc<RefCell<TreeNode>>>, key: i32) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $key\n     * @return TreeNode\n     */\n    function deleteNode($root, $key) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (delete-node root key)\n  (-> (or/c tree-node? #f) exact-integer? (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec delete_node(Root :: #tree_node{} | null, Key :: integer()) -> #tree_node{} | null.\ndelete_node(Root, Key) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec delete_node(root :: TreeNode.t | nil, key :: integer) :: TreeNode.t | nil\n  def delete_node(root, key) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? deleteNode(TreeNode? root, int key) {\n\n  }\n}"
            }
        ],
        "testcase": "[5,3,6,2,4,null,7]\n3",
        "testable": true,
        "templateMeta": {
            "name": "deleteNode",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode",
                    "dealloc": false
                },
                {
                    "name": "key",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "TreeNode"
            }
        }
    },
    {
        "id": 257,
        "fid": 257,
        "name": "Binary Tree Paths",
        "slug": "binary-tree-paths",
        "link": "https://leetcode.com/problems/binary-tree-paths/description/",
        "percent": 61.065092657047416,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "apple",
            "facebook",
            "google"
        ],
        "tags": [
            "tree",
            "depth-first-search"
        ],
        "totalAC": "593K",
        "totalSubmit": "971.1K",
        "likes": 5394,
        "dislikes": 231,
        "desc": "<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5]\n<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [&quot;1&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** binaryTreePaths(struct TreeNode* root, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<string> BinaryTreePaths(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string[]}\n */\nvar binaryTreePaths = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {String[]}\ndef binary_tree_paths(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func binaryTreePaths(_ root: TreeNode?) -> [String] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc binaryTreePaths(root *TreeNode) []string {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def binaryTreePaths(root: TreeNode): List[String] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun binaryTreePaths(root: TreeNode?): List<String> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn binary_tree_paths(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<String> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return String[]\n     */\n    function binaryTreePaths($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction binaryTreePaths(root: TreeNode | null): string[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (binary-tree-paths root)\n  (-> (or/c tree-node? #f) (listof string?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec binary_tree_paths(Root :: #tree_node{} | null) -> [unicode:unicode_binary()].\nbinary_tree_paths(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec binary_tree_paths(root :: TreeNode.t | nil) :: [String.t]\n  def binary_tree_paths(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<String> binaryTreePaths(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,3,null,5]",
        "testable": true,
        "templateMeta": {
            "name": "binaryTreePaths",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "list<string>",
                "dealloc": true
            }
        }
    },
    {
        "id": 948,
        "fid": 912,
        "name": "Sort an Array",
        "slug": "sort-an-array",
        "link": "https://leetcode.com/problems/sort-an-array/description/",
        "percent": 58.601283905036844,
        "level": "Medium",
        "category": "algorithms",
        "totalAC": "353K",
        "totalSubmit": "602.4K",
        "likes": 3219,
        "dislikes": 602,
        "desc": "<p>Given an array of integers <code>nums</code>, sort the array in ascending order and return it.</p>\n\n<p>You must solve the problem <strong>without using any built-in</strong> functions in <code>O(nlog(n))</code> time complexity and with the smallest space complexity possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,3,1]\n<strong>Output:</strong> [1,2,3,5]\n<strong>Explanation:</strong> After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,1,1,2,0,0]\n<strong>Output:</strong> [0,0,1,1,2,5]\n<strong>Explanation:</strong> Note that the values of nums are not necessairly unique.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-5 * 10<sup>4</sup> &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int[] sortArray(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* sortArray(int* nums, int numsSize, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int[] SortArray(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function(nums) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef sort_array(nums)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func sortArray(_ nums: [Int]) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func sortArray(nums []int) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def sortArray(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun sortArray(nums: IntArray): IntArray {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function sortArray($nums) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function sortArray(nums: number[]): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (sort-array nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec sort_array(Nums :: [integer()]) -> [integer()].\nsort_array(Nums) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec sort_array(nums :: [integer]) :: [integer]\n  def sort_array(nums) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<int> sortArray(List<int> nums) {\n\n  }\n}"
            }
        ],
        "testcase": "[5,2,3,1]",
        "testable": true,
        "templateMeta": {
            "name": "sortArray",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "integer[]"
            }
        }
    },
    {
        "id": 202,
        "fid": 202,
        "name": "Happy Number",
        "slug": "happy-number",
        "link": "https://leetcode.com/problems/happy-number/description/",
        "percent": 54.67927163609924,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "airbnb",
            "twitter",
            "uber"
        ],
        "tags": [
            "hash-table",
            "math"
        ],
        "totalAC": "1.1M",
        "totalSubmit": "1.9M",
        "likes": 7907,
        "dislikes": 991,
        "desc": "<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>\n\n<p>A <strong>happy number</strong> is a number defined by the following process:</p>\n\n<ul>\n\t<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>\n\t<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>\n\t<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 19\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\n1<sup>2</sup> + 9<sup>2</sup> = 82\n8<sup>2</sup> + 2<sup>2</sup> = 68\n6<sup>2</sup> + 8<sup>2</sup> = 100\n1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    bool isHappy(int n) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public boolean isHappy(int n) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "bool isHappy(int n){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public bool IsHappy(int n) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isHappy = function(n) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer} n\n# @return {Boolean}\ndef is_happy(n)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func isHappy(_ n: Int) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func isHappy(n int) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def isHappy(n: Int): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun isHappy(n: Int): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn is_happy(n: i32) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Boolean\n     */\n    function isHappy($n) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function isHappy(n: number): boolean {\n\n};"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec is_happy(N :: integer()) -> boolean().\nis_happy(N) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec is_happy(n :: integer) :: boolean\n  def is_happy(n) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  bool isHappy(int n) {\n\n  }\n}"
            }
        ],
        "testcase": "19",
        "testable": true,
        "templateMeta": {
            "name": "isHappy",
            "params": [
                {
                    "name": "n",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 242,
        "fid": 242,
        "name": "Valid Anagram",
        "slug": "valid-anagram",
        "link": "https://leetcode.com/problems/valid-anagram/description/",
        "percent": 62.936540242433736,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "amazon",
            "uber",
            "yelp"
        ],
        "tags": [
            "hash-table",
            "sort"
        ],
        "totalAC": "1.9M",
        "totalSubmit": "3.1M",
        "likes": 8100,
        "dislikes": 261,
        "desc": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"anagram\", t = \"nagaram\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"rat\", t = \"car\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "bool isAnagram(char * s, char * t){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public bool IsAnagram(string s, string t) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isAnagram = function(s, t) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @param {String} t\n# @return {Boolean}\ndef is_anagram(s, t)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func isAnagram(_ s: String, _ t: String) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func isAnagram(s string, t string) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def isAnagram(s: String, t: String): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun isAnagram(s: String, t: String): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn is_anagram(s: String, t: String) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Boolean\n     */\n    function isAnagram($s, $t) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function isAnagram(s: string, t: string): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (is-anagram s t)\n  (-> string? string? boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec is_anagram(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> boolean().\nis_anagram(S, T) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec is_anagram(s :: String.t, t :: String.t) :: boolean\n  def is_anagram(s, t) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  bool isAnagram(String s, String t) {\n\n  }\n}"
            }
        ],
        "testcase": "\"anagram\"\n\"nagaram\"",
        "testable": true,
        "templateMeta": {
            "name": "isAnagram",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                },
                {
                    "name": "t",
                    "type": "string"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 110,
        "fid": 110,
        "name": "Balanced Binary Tree",
        "slug": "balanced-binary-tree",
        "link": "https://leetcode.com/problems/balanced-binary-tree/description/",
        "percent": 48.63877336491173,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "bloomberg"
        ],
        "tags": [
            "tree",
            "depth-first-search"
        ],
        "totalAC": "1M",
        "totalSubmit": "2.1M",
        "likes": 8215,
        "dislikes": 464,
        "desc": "<p>Given a binary tree, determine if it is <span data-keyword=\"height-balanced\"><strong>height-balanced</strong></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" style=\"width: 342px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" style=\"width: 452px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool isBalanced(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsBalanced(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isBalanced = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Boolean}\ndef is_balanced(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isBalanced(_ root: TreeNode?) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isBalanced(root *TreeNode) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isBalanced(root: TreeNode): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isBalanced(root: TreeNode?): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_balanced(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function isBalanced($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isBalanced(root: TreeNode | null): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (is-balanced root)\n  (-> (or/c tree-node? #f) boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_balanced(Root :: #tree_node{} | null) -> boolean().\nis_balanced(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_balanced(root :: TreeNode.t | nil) :: boolean\n  def is_balanced(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool isBalanced(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[3,9,20,null,null,15,7]",
        "testable": true,
        "templateMeta": {
            "name": "isBalanced",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 70,
        "fid": 70,
        "name": "Climbing Stairs",
        "slug": "climbing-stairs",
        "link": "https://leetcode.com/problems/climbing-stairs/description/",
        "percent": 52.15252120106888,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "adobe",
            "apple"
        ],
        "tags": [
            "dynamic-programming"
        ],
        "totalAC": "2.2M",
        "totalSubmit": "4.2M",
        "likes": 17018,
        "dislikes": 521,
        "desc": "<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>\n\n<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 45</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int climbStairs(int n) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int climbStairs(int n) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int climbStairs(int n){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int ClimbStairs(int n) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer} n\n# @return {Integer}\ndef climb_stairs(n)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func climbStairs(_ n: Int) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func climbStairs(n int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def climbStairs(n: Int): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun climbStairs(n: Int): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn climb_stairs(n: i32) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function climbStairs($n) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function climbStairs(n: number): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (climb-stairs n)\n  (-> exact-integer? exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec climb_stairs(N :: integer()) -> integer().\nclimb_stairs(N) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec climb_stairs(n :: integer) :: integer\n  def climb_stairs(n) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int climbStairs(int n) {\n\n  }\n}"
            }
        ],
        "testcase": "2",
        "testable": true,
        "templateMeta": {
            "name": "climbStairs",
            "params": [
                {
                    "name": "n",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 104,
        "fid": 104,
        "name": "Maximum Depth of Binary Tree",
        "slug": "maximum-depth-of-binary-tree",
        "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/description/",
        "percent": 73.37602533532144,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "apple",
            "linkedin",
            "uber",
            "yahoo"
        ],
        "tags": [
            "tree",
            "depth-first-search"
        ],
        "totalAC": "2.1M",
        "totalSubmit": "2.9M",
        "likes": 9509,
        "dislikes": 156,
        "desc": "<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>\n\n<p>A binary tree&#39;s <strong>maximum depth</strong>&nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\" style=\"width: 400px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint maxDepth(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MaxDepth(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef max_depth(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func maxDepth(_ root: TreeNode?) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxDepth(root *TreeNode) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def maxDepth(root: TreeNode): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun maxDepth(root: TreeNode?): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxDepth($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxDepth(root: TreeNode | null): number {\n\n};"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec max_depth(Root :: #tree_node{} | null) -> integer().\nmax_depth(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec max_depth(root :: TreeNode.t | nil) :: integer\n  def max_depth(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int maxDepth(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[3,9,20,null,null,15,7]",
        "testable": true,
        "templateMeta": {
            "name": "maxDepth",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 203,
        "fid": 203,
        "name": "Remove Linked List Elements",
        "slug": "remove-linked-list-elements",
        "link": "https://leetcode.com/problems/remove-linked-list-elements/description/",
        "percent": 45.46444485390482,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "linked-list"
        ],
        "totalAC": "876K",
        "totalSubmit": "1.9M",
        "likes": 6695,
        "dislikes": 197,
        "desc": "<p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,6,3,4,5,6], val = 6\n<strong>Output:</strong> [1,2,3,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [], val = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [7,7,7,7], val = 7\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 50</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeElements(struct ListNode* head, int val){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RemoveElements(ListNode head, int val) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nvar removeElements = function(head, val) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} val\n# @return {ListNode}\ndef remove_elements(head, val)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func removeElements(_ head: ListNode?, _ val: Int) -> ListNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeElements(head *ListNode, val int) *ListNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def removeElements(head: ListNode, `val`: Int): ListNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun removeElements(head: ListNode?, `val`: Int): ListNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $val\n     * @return ListNode\n     */\n    function removeElements($head, $val) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction removeElements(head: ListNode | null, val: number): ListNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (remove-elements head val)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec remove_elements(Head :: #list_node{} | null, Val :: integer()) -> #list_node{} | null.\nremove_elements(Head, Val) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec remove_elements(head :: ListNode.t | nil, val :: integer) :: ListNode.t | nil\n  def remove_elements(head, val) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? removeElements(ListNode? head, int val) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,6,3,4,5,6]\n6",
        "testable": true,
        "templateMeta": {
            "name": "removeElements",
            "params": [
                {
                    "name": "head",
                    "type": "ListNode",
                    "dealloc": false
                },
                {
                    "name": "val",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "ListNode",
                "dealloc": true
            }
        }
    },
    {
        "id": 150,
        "fid": 150,
        "name": "Evaluate Reverse Polish Notation",
        "slug": "evaluate-reverse-polish-notation",
        "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/description/",
        "percent": 45.28688993069921,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "linkedin"
        ],
        "tags": [
            "stack"
        ],
        "totalAC": "614.1K",
        "totalSubmit": "1.4M",
        "likes": 5402,
        "dislikes": 845,
        "desc": "<p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\">Reverse Polish Notation</a>.</p>\n\n<p>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</p>\n\n<p><strong>Note</strong> that:</p>\n\n<ul>\n\t<li>The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.</li>\n\t<li>Each operand may be an integer or another expression.</li>\n\t<li>The division between two integers always <strong>truncates toward zero</strong>.</li>\n\t<li>There will not be any division by zero.</li>\n\t<li>The input represents a valid arithmetic expression in a reverse polish notation.</li>\n\t<li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> ((2 + 1) * 3) = 9\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> (4 + (13 / 5)) = 6\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n<strong>Output:</strong> 22\n<strong>Explanation:</strong> ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int evalRPN(String[] tokens) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int evalRPN(char ** tokens, int tokensSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int EvalRPN(string[] tokens) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string[]} tokens\n * @return {number}\n */\nvar evalRPN = function(tokens) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String[]} tokens\n# @return {Integer}\ndef eval_rpn(tokens)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func evalRPN(_ tokens: [String]) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func evalRPN(tokens []string) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def evalRPN(tokens: Array[String]): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun evalRPN(tokens: Array<String>): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn eval_rpn(tokens: Vec<String>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String[] $tokens\n     * @return Integer\n     */\n    function evalRPN($tokens) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function evalRPN(tokens: string[]): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (eval-rpn tokens)\n  (-> (listof string?) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec eval_rpn(Tokens :: [unicode:unicode_binary()]) -> integer().\neval_rpn(Tokens) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec eval_rpn(tokens :: [String.t]) :: integer\n  def eval_rpn(tokens) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int evalRPN(List<String> tokens) {\n\n  }\n}"
            }
        ],
        "testcase": "[\"2\",\"1\",\"+\",\"3\",\"*\"]",
        "testable": true,
        "templateMeta": {
            "name": "evalRPN",
            "params": [
                {
                    "name": "tokens",
                    "type": "string[]"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 77,
        "fid": 77,
        "name": "Combinations",
        "slug": "combinations",
        "link": "https://leetcode.com/problems/combinations/description/",
        "percent": 66.63164490664305,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "backtracking"
        ],
        "totalAC": "634.9K",
        "totalSubmit": "952.8K",
        "likes": 5628,
        "dislikes": 178,
        "desc": "<p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, k = 2\n<strong>Output:</strong> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n<strong>Explanation:</strong> There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 1\n<strong>Output:</strong> [[1]]\n<strong>Explanation:</strong> There is 1 choose 1 = 1 total combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combine(int n, int k, int* returnSize, int** returnColumnSizes){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public IList<IList<int>> Combine(int n, int k) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer[][]}\ndef combine(n, k)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func combine(n int, k int) [][]int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def combine(n: Int, k: Int): List[List[Int]] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun combine(n: Int, k: Int): List<List<Int>> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer[][]\n     */\n    function combine($n, $k) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function combine(n: number, k: number): number[][] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (combine n k)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec combine(N :: integer(), K :: integer()) -> [[integer()]].\ncombine(N, K) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec combine(n :: integer, k :: integer) :: [[integer]]\n  def combine(n, k) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<List<int>> combine(int n, int k) {\n\n  }\n}"
            }
        ],
        "testcase": "4\n2",
        "testable": true,
        "templateMeta": {
            "name": "combine",
            "params": [
                {
                    "name": "n",
                    "type": "integer"
                },
                {
                    "name": "k",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "list<list<integer>>",
                "dealloc": true
            }
        }
    },
    {
        "id": 59,
        "fid": 59,
        "name": "Spiral Matrix II",
        "slug": "spiral-matrix-ii",
        "link": "https://leetcode.com/problems/spiral-matrix-ii/description/",
        "percent": 67.06488245514673,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "array"
        ],
        "totalAC": "419.2K",
        "totalSubmit": "625.1K",
        "likes": 4563,
        "dislikes": 203,
        "desc": "<p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n<sup>2</sup></code> in spiral order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int[][] generateMatrix(int n) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int[][] GenerateMatrix(int n) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number} n\n * @return {number[][]}\n */\nvar generateMatrix = function(n) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer} n\n# @return {Integer[][]}\ndef generate_matrix(n)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func generateMatrix(_ n: Int) -> [[Int]] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func generateMatrix(n int) [][]int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def generateMatrix(n: Int): Array[Array[Int]] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun generateMatrix(n: Int): Array<IntArray> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer[][]\n     */\n    function generateMatrix($n) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function generateMatrix(n: number): number[][] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (generate-matrix n)\n  (-> exact-integer? (listof (listof exact-integer?)))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec generate_matrix(N :: integer()) -> [[integer()]].\ngenerate_matrix(N) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec generate_matrix(n :: integer) :: [[integer]]\n  def generate_matrix(n) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<List<int>> generateMatrix(int n) {\n\n  }\n}"
            }
        ],
        "testcase": "3",
        "testable": true,
        "templateMeta": {
            "name": "generateMatrix",
            "params": [
                {
                    "name": "n",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer[][]",
                "rowsize": "param_1",
                "colsize": "param_1",
                "dealloc": true
            }
        }
    },
    {
        "id": 55,
        "fid": 55,
        "name": "Jump Game",
        "slug": "jump-game",
        "link": "https://leetcode.com/problems/jump-game/description/",
        "percent": 38.86961030435719,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "microsoft"
        ],
        "tags": [
            "array",
            "greedy"
        ],
        "totalAC": "1.3M",
        "totalSubmit": "3.4M",
        "likes": 15341,
        "dislikes": 785,
        "desc": "<p>You are given an integer array <code>nums</code>. You are initially positioned at the array&#39;s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p>\n\n<p>Return <code>true</code><em> if you can reach the last index, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1,0,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "bool canJump(int* nums, int numsSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public bool CanJump(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_jump(nums)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func canJump(_ nums: [Int]) -> Bool {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func canJump(nums []int) bool {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def canJump(nums: Array[Int]): Boolean = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun canJump(nums: IntArray): Boolean {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn can_jump(nums: Vec<i32>) -> bool {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canJump($nums) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function canJump(nums: number[]): boolean {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (can-jump nums)\n  (-> (listof exact-integer?) boolean?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec can_jump(Nums :: [integer()]) -> boolean().\ncan_jump(Nums) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec can_jump(nums :: [integer]) :: boolean\n  def can_jump(nums) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  bool canJump(List<int> nums) {\n\n  }\n}"
            }
        ],
        "testcase": "[2,3,1,1,4]",
        "testable": true,
        "templateMeta": {
            "name": "canJump",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "boolean"
            }
        }
    },
    {
        "id": 145,
        "fid": 145,
        "name": "Binary Tree Postorder Traversal",
        "slug": "binary-tree-postorder-traversal",
        "link": "https://leetcode.com/problems/binary-tree-postorder-traversal/description/",
        "percent": 67.41684483491738,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "stack",
            "tree"
        ],
        "totalAC": "900.6K",
        "totalSubmit": "1.3M",
        "likes": 5541,
        "dislikes": 164,
        "desc": "<p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg\" style=\"width: 127px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* postorderTraversal(struct TreeNode* root, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> PostorderTraversal(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer[]}\ndef postorder_traversal(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc postorderTraversal(root *TreeNode) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def postorderTraversal(root: TreeNode): List[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun postorderTraversal(root: TreeNode?): List<Int> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn postorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function postorderTraversal($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction postorderTraversal(root: TreeNode | null): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (postorder-traversal root)\n  (-> (or/c tree-node? #f) (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec postorder_traversal(Root :: #tree_node{} | null) -> [integer()].\npostorder_traversal(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec postorder_traversal(root :: TreeNode.t | nil) :: [integer]\n  def postorder_traversal(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<int> postorderTraversal(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,null,2,3]",
        "testable": true,
        "templateMeta": {
            "name": "postorderTraversal",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "list<integer>",
                "dealloc": true
            }
        }
    },
    {
        "id": 347,
        "fid": 347,
        "name": "Top K Frequent Elements",
        "slug": "top-k-frequent-elements",
        "link": "https://leetcode.com/problems/top-k-frequent-elements/description/",
        "percent": 64.46793250052099,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "pocketgems",
            "yelp"
        ],
        "tags": [
            "hash-table",
            "heap"
        ],
        "totalAC": "1.3M",
        "totalSubmit": "2M",
        "likes": 12541,
        "dislikes": 462,
        "desc": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1,2,2,3], k = 2\n<strong>Output:</strong> [1,2]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>\n\t<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Your algorithm&#39;s time complexity must be better than <code>O(n log n)</code>, where n is the array&#39;s size.</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int[] TopKFrequent(int[] nums, int k) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef top_k_frequent(nums, k)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func topKFrequent(nums []int, k int) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def topKFrequent(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun topKFrequent(nums: IntArray, k: Int): IntArray {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function topKFrequent($nums, $k) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function topKFrequent(nums: number[], k: number): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (top-k-frequent nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec top_k_frequent(Nums :: [integer()], K :: integer()) -> [integer()].\ntop_k_frequent(Nums, K) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec top_k_frequent(nums :: [integer], k :: integer) :: [integer]\n  def top_k_frequent(nums, k) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<int> topKFrequent(List<int> nums, int k) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,1,1,2,2,3]\n2",
        "testable": true,
        "templateMeta": {
            "name": "topKFrequent",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                },
                {
                    "name": "k",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer[]"
            }
        }
    },
    {
        "id": 669,
        "fid": 669,
        "name": "Trim a Binary Search Tree",
        "slug": "trim-a-binary-search-tree",
        "link": "https://leetcode.com/problems/trim-a-binary-search-tree/description/",
        "percent": 66.3482994940114,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "bloomberg"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "259K",
        "totalSubmit": "390.3K",
        "likes": 5249,
        "dislikes": 246,
        "desc": "<p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node&#39;s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>\n\n<p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" style=\"width: 450px; height: 126px;\" />\n<pre>\n<strong>Input:</strong> root = [1,0,2], low = 1, high = 2\n<strong>Output:</strong> [1,null,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" style=\"width: 450px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n<strong>Output:</strong> [3,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The value of each node in the tree is <strong>unique</strong>.</li>\n\t<li><code>root</code> is guaranteed to be a valid binary search tree.</li>\n\t<li><code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def trimBST(self, root, low, high):\n        \"\"\"\n        :type root: TreeNode\n        :type low: int\n        :type high: int\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* trimBST(struct TreeNode* root, int low, int high){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode TrimBST(TreeNode root, int low, int high) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} low\n * @param {number} high\n * @return {TreeNode}\n */\nvar trimBST = function(root, low, high) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer} low\n# @param {Integer} high\n# @return {TreeNode}\ndef trim_bst(root, low, high)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func trimBST(_ root: TreeNode?, _ low: Int, _ high: Int) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc trimBST(root *TreeNode, low int, high int) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def trimBST(root: TreeNode, low: Int, high: Int): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun trimBST(root: TreeNode?, low: Int, high: Int): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn trim_bst(root: Option<Rc<RefCell<TreeNode>>>, low: i32, high: i32) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $low\n     * @param Integer $high\n     * @return TreeNode\n     */\n    function trimBST($root, $low, $high) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction trimBST(root: TreeNode | null, low: number, high: number): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (trim-bst root low high)\n  (-> (or/c tree-node? #f) exact-integer? exact-integer? (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec trim_bst(Root :: #tree_node{} | null, Low :: integer(), High :: integer()) -> #tree_node{} | null.\ntrim_bst(Root, Low, High) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec trim_bst(root :: TreeNode.t | nil, low :: integer, high :: integer) :: TreeNode.t | nil\n  def trim_bst(root, low, high) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? trimBST(TreeNode? root, int low, int high) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,0,2]\n1\n2",
        "testable": true,
        "templateMeta": {
            "name": "trimBST",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                },
                {
                    "name": "low",
                    "type": "integer"
                },
                {
                    "name": "high",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "TreeNode"
            }
        }
    },
    {
        "id": 160,
        "fid": 160,
        "name": "Intersection of Two Linked Lists",
        "slug": "intersection-of-two-linked-lists",
        "link": "https://leetcode.com/problems/intersection-of-two-linked-lists/description/",
        "percent": 53.88374929857047,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "airbnb",
            "amazon",
            "bloomberg",
            "microsoft"
        ],
        "tags": [
            "linked-list"
        ],
        "totalAC": "1.2M",
        "totalSubmit": "2.2M",
        "likes": 12190,
        "dislikes": 1105,
        "desc": "<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>\n\n<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_statement.png\" style=\"width: 500px; height: 162px;\" />\n<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>\n\n<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>\n\n<ul>\n\t<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>\n\t<li><code>listA</code> - The first linked list.</li>\n\t<li><code>listB</code> - The second linked list.</li>\n\t<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>\n\t<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>\n</ul>\n\n<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png\" style=\"width: 500px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n<strong>Output:</strong> Intersected at &#39;8&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node&#39;s value is not 1 because the nodes with value 1 in A and B (2<sup>nd</sup> node in A and 3<sup>rd</sup> node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3<sup>rd</sup> node in A and 4<sup>th</sup> node in B) point to the same location in memory.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png\" style=\"width: 500px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>Output:</strong> Intersected at &#39;2&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png\" style=\"width: 300px; height: 189px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>Output:</strong> No intersection\n<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li>\n\t<li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;&nbsp;m</code></li>\n\t<li><code>0 &lt;= skipB &lt;&nbsp;n</code></li>\n\t<li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li>\n\t<li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    \n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val)\n#         @val = val\n#         @next = nil\n#     end\n# end\n\n# @param {ListNode} headA\n# @param {ListNode} headB\n# @return {ListNode}\ndef getIntersectionNode(headA, headB)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.next = nil\n *     }\n * }\n */\n\nclass Solution {\n    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode(var _x: Int = 0) {\n *   var next: ListNode = null\n *   var x: Int = _x\n * }\n */\n\nobject Solution {\n    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\n\nclass Solution {\n    fun getIntersectionNode(headA:ListNode?, headB:ListNode?):ListNode? {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) { $this->val = $val; }\n * }\n */\n\nclass Solution {\n    /**\n     * @param ListNode $headA\n     * @param ListNode $headB\n     * @return ListNode\n     */\n    function getIntersectionNode($headA, $headB) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n\n};"
            }
        ],
        "testcase": "8\n[4,1,8,4,5]\n[5,6,1,8,4,5]\n2\n3",
        "testable": true,
        "templateMeta": {
            "name": "getIntersectionNode",
            "params": [
                {
                    "name": "intersectVal",
                    "type": "integer"
                },
                {
                    "name": "listA",
                    "type": "ListNode"
                },
                {
                    "name": "listB",
                    "type": "ListNode"
                },
                {
                    "name": "skipA",
                    "type": "integer"
                },
                {
                    "name": "skipB",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "ListNode"
            },
            "languages": [
                "cpp",
                "java",
                "python",
                "c",
                "csharp",
                "javascript",
                "golang",
                "python3",
                "swift",
                "ruby",
                "kotlin",
                "scala",
                "php",
                "typescript"
            ],
            "manual": true
        }
    },
    {
        "id": 784,
        "fid": 701,
        "name": "Insert into a Binary Search Tree",
        "slug": "insert-into-a-binary-search-tree",
        "link": "https://leetcode.com/problems/insert-into-a-binary-search-tree/description/",
        "percent": 74.43483082243965,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "tree"
        ],
        "totalAC": "384K",
        "totalSubmit": "515.8K",
        "likes": 4497,
        "dislikes": 156,
        "desc": "<p>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>\n\n<p><strong>Notice</strong>&nbsp;that there may exist&nbsp;multiple valid ways for the&nbsp;insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" style=\"width: 752px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n<strong>Explanation:</strong> Another accepted tree is:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/bst.jpg\" style=\"width: 352px; height: 301px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [40,20,60,10,30,50,70], val = 25\n<strong>Output:</strong> [40,20,60,10,30,50,70,null,null,25]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in&nbsp;the tree will be in the range <code>[0,&nbsp;10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>8</sup> &lt;= Node.val &lt;= 10<sup>8</sup></code></li>\n\t<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>-10<sup>8</sup> &lt;= val &lt;= 10<sup>8</sup></code></li>\n\t<li>It&#39;s <strong>guaranteed</strong> that <code>val</code> does not exist in the original BST.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode InsertIntoBST(TreeNode root, int val) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nvar insertIntoBST = function(root, val) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer} val\n# @return {TreeNode}\ndef insert_into_bst(root, val)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc insertIntoBST(root *TreeNode, val int) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def insertIntoBST(root: TreeNode, `val`: Int): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun insertIntoBST(root: TreeNode?, `val`: Int): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn insert_into_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $val\n     * @return TreeNode\n     */\n    function insertIntoBST($root, $val) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction insertIntoBST(root: TreeNode | null, val: number): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (insert-into-bst root val)\n  (-> (or/c tree-node? #f) exact-integer? (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec insert_into_bst(Root :: #tree_node{} | null, Val :: integer()) -> #tree_node{} | null.\ninsert_into_bst(Root, Val) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec insert_into_bst(root :: TreeNode.t | nil, val :: integer) :: TreeNode.t | nil\n  def insert_into_bst(root, val) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? insertIntoBST(TreeNode? root, int val) {\n\n  }\n}"
            }
        ],
        "testcase": "[4,2,7,1,3]\n5",
        "testable": true,
        "templateMeta": {
            "name": "insertIntoBST",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                },
                {
                    "name": "val",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "TreeNode"
            }
        }
    },
    {
        "id": 151,
        "fid": 151,
        "name": "Reverse Words in a String",
        "slug": "reverse-words-in-a-string",
        "link": "https://leetcode.com/problems/reverse-words-in-a-string/description/",
        "percent": 32.299166720737624,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "apple",
            "bloomberg",
            "microsoft",
            "snapchat",
            "yelp"
        ],
        "tags": [
            "string"
        ],
        "totalAC": "881.1K",
        "totalSubmit": "2.7M",
        "likes": 5400,
        "dislikes": 4478,
        "desc": "<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;the sky is blue&quot;\n<strong>Output:</strong> &quot;blue is sky the&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;  hello world  &quot;\n<strong>Output:</strong> &quot;world hello&quot;\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a good   example&quot;\n<strong>Output:</strong> &quot;example good a&quot;\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    string reverseWords(string s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public String reverseWords(String s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "char * reverseWords(char * s){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public string ReverseWords(string s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {String} s\n# @return {String}\ndef reverse_words(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func reverseWords(_ s: String) -> String {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func reverseWords(s string) string {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def reverseWords(s: String): String = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun reverseWords(s: String): String {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn reverse_words(s: String) -> String {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function reverseWords($s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function reverseWords(s: string): string {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (reverse-words s)\n  (-> string? string?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec reverse_words(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nreverse_words(S) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec reverse_words(s :: String.t) :: String.t\n  def reverse_words(s) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  String reverseWords(String s) {\n\n  }\n}"
            }
        ],
        "testcase": "\"the sky is blue\"",
        "testable": true,
        "templateMeta": {
            "name": "reverseWords",
            "params": [
                {
                    "name": "s",
                    "type": "string"
                }
            ],
            "return": {
                "type": "string"
            }
        }
    },
    {
        "id": 106,
        "fid": 106,
        "name": "Construct Binary Tree from Inorder and Postorder Traversal",
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "link": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/",
        "percent": 57.88224181519244,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "microsoft"
        ],
        "tags": [
            "array",
            "tree",
            "depth-first-search"
        ],
        "totalAC": "458.4K",
        "totalSubmit": "791.9K",
        "likes": 5690,
        "dislikes": 85,
        "desc": "<p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> inorder = [-1], postorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n\t<li><code>postorder.length == inorder.length</code></li>\n\t<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n\t<li><code>inorder</code> and <code>postorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>postorder</code> also appears in <code>inorder</code>.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n\t<li><code>postorder</code> is <strong>guaranteed</strong> to be the postorder traversal of the tree.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode BuildTree(int[] inorder, int[] postorder) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nvar buildTree = function(inorder, postorder) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {Integer[]} inorder\n# @param {Integer[]} postorder\n# @return {TreeNode}\ndef build_tree(inorder, postorder)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc buildTree(inorder []int, postorder []int) *TreeNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def buildTree(inorder: Array[Int], postorder: Array[Int]): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun buildTree(inorder: IntArray, postorder: IntArray): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param Integer[] $inorder\n     * @param Integer[] $postorder\n     * @return TreeNode\n     */\n    function buildTree($inorder, $postorder) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (build-tree inorder postorder)\n  (-> (listof exact-integer?) (listof exact-integer?) (or/c tree-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec build_tree(Inorder :: [integer()], Postorder :: [integer()]) -> #tree_node{} | null.\nbuild_tree(Inorder, Postorder) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec build_tree(inorder :: [integer], postorder :: [integer]) :: TreeNode.t | nil\n  def build_tree(inorder, postorder) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? buildTree(List<int> inorder, List<int> postorder) {\n\n  }\n}"
            }
        ],
        "testcase": "[9,3,15,20,7]\n[9,15,7,20,3]",
        "testable": true,
        "templateMeta": {
            "name": "buildTree",
            "params": [
                {
                    "name": "inorder",
                    "type": "integer[]"
                },
                {
                    "name": "postorder",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "TreeNode",
                "dealloc": true
            }
        }
    },
    {
        "id": 1236,
        "fid": 1137,
        "name": "N-th Tribonacci Number",
        "slug": "n-th-tribonacci-number",
        "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/",
        "percent": 63.80394751413376,
        "level": "Easy",
        "category": "algorithms",
        "totalAC": "456.6K",
        "totalSubmit": "715.5K",
        "likes": 3355,
        "dislikes": 154,
        "desc": "<p>The Tribonacci sequence T<sub>n</sub> is defined as follows:&nbsp;</p>\r\n\r\n<p>T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, and T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub> for n &gt;= 0.</p>\r\n\r\n<p>Given <code>n</code>, return the value of T<sub>n</sub>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 4\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong>\r\nT_3 = 0 + 1 + 1 = 2\r\nT_4 = 1 + 1 + 2 = 4\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 25\r\n<strong>Output:</strong> 1389537\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= n &lt;= 37</code></li>\r\n\t<li>The answer is guaranteed to fit within a 32-bit integer, ie. <code>answer &lt;= 2^31 - 1</code>.</li>\r\n</ul>",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int tribonacci(int n) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int tribonacci(int n) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def tribonacci(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def tribonacci(self, n: int) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "\n\nint tribonacci(int n){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int Tribonacci(int n) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar tribonacci = function(n) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer} n\n# @return {Integer}\ndef tribonacci(n)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func tribonacci(_ n: Int) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func tribonacci(n int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def tribonacci(n: Int): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun tribonacci(n: Int): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn tribonacci(n: i32) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function tribonacci($n) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function tribonacci(n: number): number {\n\n};"
            }
        ],
        "testcase": "4",
        "testable": true,
        "templateMeta": {
            "name": "tribonacci",
            "params": [
                {
                    "name": "n",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 1019,
        "fid": 977,
        "name": "Squares of a Sorted Array",
        "slug": "squares-of-a-sorted-array",
        "link": "https://leetcode.com/problems/squares-of-a-sorted-array/description/",
        "percent": 71.92185514612453,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "array",
            "two-pointers"
        ],
        "totalAC": "1.3M",
        "totalSubmit": "1.8M",
        "likes": 7269,
        "dislikes": 181,
        "desc": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>an array of <strong>the squares of each number</strong> sorted in non-decreasing order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-4,-1,0,3,10]\n<strong>Output:</strong> [0,1,9,16,100]\n<strong>Explanation:</strong> After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-7,-3,2,3,11]\n<strong>Output:</strong> [4,9,9,49,121]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code><span>1 &lt;= nums.length &lt;= </span>10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Squaring each element and sorting the new array is very trivial, could you find an <code>O(n)</code> solution using a different approach?",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def sortedSquares(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* sortedSquares(int* nums, int numsSize, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortedSquares = function(nums) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef sorted_squares(nums)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func sortedSquares(_ nums: [Int]) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func sortedSquares(nums []int) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun sortedSquares(nums: IntArray): IntArray {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function sortedSquares($nums) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function sortedSquares(nums: number[]): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (sorted-squares nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec sorted_squares(Nums :: [integer()]) -> [integer()].\nsorted_squares(Nums) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec sorted_squares(nums :: [integer]) :: [integer]\n  def sorted_squares(nums) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<int> sortedSquares(List<int> nums) {\n\n  }\n}"
            }
        ],
        "testcase": "[-4,-1,0,3,10]",
        "testable": true,
        "templateMeta": {
            "name": "sortedSquares",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "integer[]"
            }
        }
    },
    {
        "id": 111,
        "fid": 111,
        "name": "Minimum Depth of Binary Tree",
        "slug": "minimum-depth-of-binary-tree",
        "link": "https://leetcode.com/problems/minimum-depth-of-binary-tree/description/",
        "percent": 44.05339775931202,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "tree",
            "depth-first-search",
            "breadth-first-search"
        ],
        "totalAC": "894.2K",
        "totalSubmit": "2M",
        "likes": 5329,
        "dislikes": 1072,
        "desc": "<p>Given a binary tree, find its minimum depth.</p>\n\n<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>\n\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" style=\"width: 432px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minDepth(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint minDepth(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MinDepth(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDepth = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef min_depth(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func minDepth(_ root: TreeNode?) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc minDepth(root *TreeNode) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def minDepth(root: TreeNode): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun minDepth(root: TreeNode?): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn min_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function minDepth($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction minDepth(root: TreeNode | null): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (min-depth root)\n  (-> (or/c tree-node? #f) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec min_depth(Root :: #tree_node{} | null) -> integer().\nmin_depth(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec min_depth(root :: TreeNode.t | nil) :: integer\n  def min_depth(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int minDepth(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[3,9,20,null,null,15,7]",
        "testable": true,
        "templateMeta": {
            "name": "minDepth",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 303,
        "fid": 303,
        "name": "Range Sum Query - Immutable",
        "slug": "range-sum-query-immutable",
        "link": "https://leetcode.com/problems/range-sum-query-immutable/description/",
        "percent": 58.846694716309244,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "palantir"
        ],
        "tags": [
            "dynamic-programming"
        ],
        "totalAC": "417.2K",
        "totalSubmit": "707.9K",
        "likes": 2589,
        "dislikes": 1779,
        "desc": "<p>Given an integer array <code>nums</code>, handle multiple queries of the following type:</p>\n\n<ol>\n\t<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>\n</ol>\n\n<p>Implement the <code>NumArray</code> class:</p>\n\n<ul>\n\t<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>\n\t<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n<strong>Output</strong>\n[null, 1, -1, -3]\n\n<strong>Explanation</strong>\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRange</code>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class NumArray {\npublic:\n    NumArray(vector<int>& nums) {\n        \n    }\n    \n    int sumRange(int left, int right) {\n        \n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * int param_1 = obj->sumRange(left,right);\n */"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class NumArray {\n\n    public NumArray(int[] nums) {\n        \n    }\n    \n    public int sumRange(int left, int right) {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(left,right);\n */"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class NumArray(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        \n\n    def sumRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# param_1 = obj.sumRange(left,right)"
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        \n\n    def sumRange(self, left: int, right: int) -> int:\n        \n\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# param_1 = obj.sumRange(left,right)"
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "\n\n\ntypedef struct {\n    \n} NumArray;\n\n\nNumArray* numArrayCreate(int* nums, int numsSize) {\n    \n}\n\nint numArraySumRange(NumArray* obj, int left, int right) {\n  \n}\n\nvoid numArrayFree(NumArray* obj) {\n    \n}\n\n/**\n * Your NumArray struct will be instantiated and called as such:\n * NumArray* obj = numArrayCreate(nums, numsSize);\n * int param_1 = numArraySumRange(obj, left, right);\n \n * numArrayFree(obj);\n*/"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class NumArray {\n\n    public NumArray(int[] nums) {\n        \n    }\n    \n    public int SumRange(int left, int right) {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.SumRange(left,right);\n */"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n */\nvar NumArray = function(nums) {\n    \n};\n\n/** \n * @param {number} left \n * @param {number} right\n * @return {number}\n */\nNumArray.prototype.sumRange = function(left, right) {\n    \n};\n\n/** \n * Your NumArray object will be instantiated and called as such:\n * var obj = new NumArray(nums)\n * var param_1 = obj.sumRange(left,right)\n */"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "class NumArray\n\n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n        \n    end\n\n\n=begin\n    :type left: Integer\n    :type right: Integer\n    :rtype: Integer\n=end\n    def sum_range(left, right)\n        \n    end\n\n\nend\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray.new(nums)\n# param_1 = obj.sum_range(left, right)"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "\nclass NumArray {\n\n    init(_ nums: [Int]) {\n        \n    }\n    \n    func sumRange(_ left: Int, _ right: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * let obj = NumArray(nums)\n * let ret_1: Int = obj.sumRange(left, right)\n */"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "type NumArray struct {\n    \n}\n\n\nfunc Constructor(nums []int) NumArray {\n    \n}\n\n\nfunc (this *NumArray) SumRange(left int, right int) int {\n    \n}\n\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * obj := Constructor(nums);\n * param_1 := obj.SumRange(left,right);\n */"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "class NumArray(_nums: Array[Int]) {\n\n    def sumRange(left: Int, right: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * var obj = new NumArray(nums)\n * var param_1 = obj.sumRange(left,right)\n */"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class NumArray(nums: IntArray) {\n\n    fun sumRange(left: Int, right: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * var obj = NumArray(nums)\n * var param_1 = obj.sumRange(left,right)\n */"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "struct NumArray {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl NumArray {\n\n    fn new(nums: Vec<i32>) -> Self {\n        \n    }\n    \n    fn sum_range(&self, left: i32, right: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * let obj = NumArray::new(nums);\n * let ret_1: i32 = obj.sum_range(left, right);\n */"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class NumArray {\n    /**\n     * @param Integer[] $nums\n     */\n    function __construct($nums) {\n        \n    }\n  \n    /**\n     * @param Integer $left\n     * @param Integer $right\n     * @return Integer\n     */\n    function sumRange($left, $right) {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * $obj = NumArray($nums);\n * $ret_1 = $obj->sumRange($left, $right);\n */"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "class NumArray {\n    constructor(nums: number[]) {\n\n    }\n\n    sumRange(left: number, right: number): number {\n\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * var obj = new NumArray(nums)\n * var param_1 = obj.sumRange(left,right)\n */"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define num-array%\n  (class object%\n    (super-new)\n\n    ; nums : (listof exact-integer?)\n    (init-field\n      nums)\n    \n    ; sum-range : exact-integer? exact-integer? -> exact-integer?\n    (define/public (sum-range left right)\n\n      )))\n\n;; Your num-array% object will be instantiated and called as such:\n;; (define obj (new num-array% [nums nums]))\n;; (define param_1 (send obj sum-range left right))"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec num_array_init_(Nums :: [integer()]) -> any().\nnum_array_init_(Nums) ->\n  .\n\n-spec num_array_sum_range(Left :: integer(), Right :: integer()) -> integer().\nnum_array_sum_range(Left, Right) ->\n  .\n\n\n%% Your functions will be called as such:\n%% num_array_init_(Nums),\n%% Param_1 = num_array_sum_range(Left, Right),\n\n%% num_array_init_ will be called before every test case, in which you can do some necessary initializations."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule NumArray do\n  @spec init_(nums :: [integer]) :: any\n  def init_(nums) do\n\n  end\n\n  @spec sum_range(left :: integer, right :: integer) :: integer\n  def sum_range(left, right) do\n\n  end\nend\n\n# Your functions will be called as such:\n# NumArray.init_(nums)\n# param_1 = NumArray.sum_range(left, right)\n\n# NumArray.init_ will be called before every test case, in which you can do some necessary initializations."
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class NumArray {\n\n  NumArray(List<int> nums) {\n\n  }\n  \n  int sumRange(int left, int right) {\n\n  }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = NumArray(nums);\n * int param1 = obj.sumRange(left,right);\n */"
            }
        ],
        "testcase": "[\"NumArray\",\"sumRange\",\"sumRange\",\"sumRange\"]\n[[[-2,0,3,-5,2,-1]],[0,2],[2,5],[0,5]]",
        "testable": true,
        "templateMeta": {
            "classname": "NumArray",
            "maxbytesperline": 135000,
            "constructor": {
                "params": [
                    {
                        "type": "integer[]",
                        "name": "nums"
                    },
                    {
                        "type": "integer",
                        "name": "numsSize",
                        "lang": "c",
                        "value": "size_1"
                    }
                ]
            },
            "methods": [
                {
                    "name": "sumRange",
                    "params": [
                        {
                            "type": "integer",
                            "name": "left"
                        },
                        {
                            "type": "integer",
                            "name": "right"
                        }
                    ],
                    "return": {
                        "type": "integer"
                    }
                }
            ],
            "systemdesign": true,
            "params": [
                {
                    "name": "inputs",
                    "type": "integer[]"
                },
                {
                    "name": "inputs",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "list<String>",
                "dealloc": true
            }
        }
    },
    {
        "id": 239,
        "fid": 239,
        "name": "Sliding Window Maximum",
        "slug": "sliding-window-maximum",
        "link": "https://leetcode.com/problems/sliding-window-maximum/description/",
        "percent": 46.455481547525395,
        "level": "Hard",
        "category": "algorithms",
        "companies": [
            "amazon",
            "google",
            "zenefits"
        ],
        "tags": [
            "heap",
            "sliding-window"
        ],
        "totalAC": "717.5K",
        "totalSubmit": "1.5M",
        "likes": 13446,
        "dislikes": 434,
        "desc": "<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int[] MaxSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef max_sliding_window(nums, k)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func maxSlidingWindow(nums []int, k int) []int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function maxSlidingWindow($nums, $k) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function maxSlidingWindow(nums: number[], k: number): number[] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (max-sliding-window nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec max_sliding_window(Nums :: [integer()], K :: integer()) -> [integer()].\nmax_sliding_window(Nums, K) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec max_sliding_window(nums :: [integer], k :: integer) :: [integer]\n  def max_sliding_window(nums, k) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<int> maxSlidingWindow(List<int> nums, int k) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,3,-1,-3,5,3,6,7]\n3",
        "testable": true,
        "templateMeta": {
            "name": "maxSlidingWindow",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                },
                {
                    "name": "k",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer[]"
            }
        }
    },
    {
        "id": 513,
        "fid": 513,
        "name": "Find Bottom Left Tree Value",
        "slug": "find-bottom-left-tree-value",
        "link": "https://leetcode.com/problems/find-bottom-left-tree-value/description/",
        "percent": 66.72076169286895,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "microsoft"
        ],
        "tags": [
            "tree",
            "depth-first-search",
            "breadth-first-search"
        ],
        "totalAC": "203.9K",
        "totalSubmit": "305.6K",
        "likes": 2729,
        "dislikes": 235,
        "desc": "<p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg\" style=\"width: 432px; height: 421px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,null,5,6,null,null,7]\n<strong>Output:</strong> 7\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint findBottomLeftValue(struct TreeNode* root){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int FindBottomLeftValue(TreeNode root) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef find_bottom_left_value(root)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func findBottomLeftValue(_ root: TreeNode?) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findBottomLeftValue(root *TreeNode) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def findBottomLeftValue(root: TreeNode): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun findBottomLeftValue(root: TreeNode?): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn find_bottom_left_value(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function findBottomLeftValue($root) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findBottomLeftValue(root: TreeNode | null): number {\n\n};"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec find_bottom_left_value(Root :: #tree_node{} | null) -> integer().\nfind_bottom_left_value(Root) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec find_bottom_left_value(root :: TreeNode.t | nil) :: integer\n  def find_bottom_left_value(root) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int findBottomLeftValue(TreeNode? root) {\n\n  }\n}"
            }
        ],
        "testcase": "[2,1,3]",
        "testable": true,
        "templateMeta": {
            "name": "findBottomLeftValue",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 18,
        "fid": 18,
        "name": "4Sum",
        "slug": "4sum",
        "link": "https://leetcode.com/problems/4sum/description/",
        "percent": 36.12525740811389,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "linkedin"
        ],
        "tags": [
            "array",
            "hash-table",
            "two-pointers"
        ],
        "totalAC": "699.8K",
        "totalSubmit": "1.9M",
        "likes": 8558,
        "dislikes": 996,
        "desc": "<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0\n<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2], target = 8\n<strong>Output:</strong> [[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public IList<IList<int>> FourSum(int[] nums, int target) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function(nums, target) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[][]}\ndef four_sum(nums, target)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func fourSum(nums []int, target int) [][]int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def fourSum(nums: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function fourSum($nums, $target) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function fourSum(nums: number[], target: number): number[][] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (four-sum nums target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec four_sum(Nums :: [integer()], Target :: integer()) -> [[integer()]].\nfour_sum(Nums, Target) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec four_sum(nums :: [integer], target :: integer) :: [[integer]]\n  def four_sum(nums, target) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<List<int>> fourSum(List<int> nums, int target) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,0,-1,0,-2,2]\n0",
        "testable": true,
        "templateMeta": {
            "name": "fourSum",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                },
                {
                    "name": "target",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "list<list<integer>>",
                "colsize": 4,
                "dealloc": true
            }
        }
    },
    {
        "id": 225,
        "fid": 225,
        "name": "Implement Stack using Queues",
        "slug": "implement-stack-using-queues",
        "link": "https://leetcode.com/problems/implement-stack-using-queues/description/",
        "percent": 58.206166432357335,
        "level": "Easy",
        "category": "algorithms",
        "companies": [
            "bloomberg"
        ],
        "tags": [
            "stack",
            "design"
        ],
        "totalAC": "421.5K",
        "totalSubmit": "724.1K",
        "likes": 3957,
        "dislikes": 961,
        "desc": "<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyStack</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>\n\t<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>\n\t<li><code>int top()</code> Returns the element on the top of the stack.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><b>Notes:</b></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 2, 2, false]\n\n<strong>Explanation</strong>\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>top</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the stack using only one queue?</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class MyStack {\npublic:\n    MyStack() {\n        \n    }\n    \n    void push(int x) {\n        \n    }\n    \n    int pop() {\n        \n    }\n    \n    int top() {\n        \n    }\n    \n    bool empty() {\n        \n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class MyStack {\n\n    public MyStack() {\n        \n    }\n    \n    public void push(int x) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n    \n    public int top() {\n        \n    }\n    \n    public boolean empty() {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class MyStack(object):\n\n    def __init__(self):\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def top(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()"
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class MyStack:\n\n    def __init__(self):\n        \n\n    def push(self, x: int) -> None:\n        \n\n    def pop(self) -> int:\n        \n\n    def top(self) -> int:\n        \n\n    def empty(self) -> bool:\n        \n\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()"
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "\n\n\ntypedef struct {\n    \n} MyStack;\n\n\nMyStack* myStackCreate() {\n    \n}\n\nvoid myStackPush(MyStack* obj, int x) {\n  \n}\n\nint myStackPop(MyStack* obj) {\n  \n}\n\nint myStackTop(MyStack* obj) {\n  \n}\n\nbool myStackEmpty(MyStack* obj) {\n  \n}\n\nvoid myStackFree(MyStack* obj) {\n    \n}\n\n/**\n * Your MyStack struct will be instantiated and called as such:\n * MyStack* obj = myStackCreate();\n * myStackPush(obj, x);\n \n * int param_2 = myStackPop(obj);\n \n * int param_3 = myStackTop(obj);\n \n * bool param_4 = myStackEmpty(obj);\n \n * myStackFree(obj);\n*/"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class MyStack {\n\n    public MyStack() {\n        \n    }\n    \n    public void Push(int x) {\n        \n    }\n    \n    public int Pop() {\n        \n    }\n    \n    public int Top() {\n        \n    }\n    \n    public bool Empty() {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Top();\n * bool param_4 = obj.Empty();\n */"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "\nvar MyStack = function() {\n    \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyStack.prototype.push = function(x) {\n    \n};\n\n/**\n * @return {number}\n */\nMyStack.prototype.pop = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMyStack.prototype.top = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyStack.prototype.empty = function() {\n    \n};\n\n/** \n * Your MyStack object will be instantiated and called as such:\n * var obj = new MyStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "class MyStack\n    def initialize()\n        \n    end\n\n\n=begin\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def top()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def empty()\n        \n    end\n\n\nend\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack.new()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "\nclass MyStack {\n\n    init() {\n        \n    }\n    \n    func push(_ x: Int) {\n        \n    }\n    \n    func pop() -> Int {\n        \n    }\n    \n    func top() -> Int {\n        \n    }\n    \n    func empty() -> Bool {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * let obj = MyStack()\n * obj.push(x)\n * let ret_2: Int = obj.pop()\n * let ret_3: Int = obj.top()\n * let ret_4: Bool = obj.empty()\n */"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "type MyStack struct {\n    \n}\n\n\nfunc Constructor() MyStack {\n    \n}\n\n\nfunc (this *MyStack) Push(x int)  {\n    \n}\n\n\nfunc (this *MyStack) Pop() int {\n    \n}\n\n\nfunc (this *MyStack) Top() int {\n    \n}\n\n\nfunc (this *MyStack) Empty() bool {\n    \n}\n\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.Empty();\n */"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "class MyStack() {\n\n    def push(x: Int) {\n        \n    }\n\n    def pop(): Int = {\n        \n    }\n\n    def top(): Int = {\n        \n    }\n\n    def empty(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * var obj = new MyStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class MyStack() {\n\n    fun push(x: Int) {\n        \n    }\n\n    fun pop(): Int {\n        \n    }\n\n    fun top(): Int {\n        \n    }\n\n    fun empty(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * var obj = MyStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "struct MyStack {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyStack {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn push(&self, x: i32) {\n        \n    }\n    \n    fn pop(&self) -> i32 {\n        \n    }\n    \n    fn top(&self) -> i32 {\n        \n    }\n    \n    fn empty(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * let obj = MyStack::new();\n * obj.push(x);\n * let ret_2: i32 = obj.pop();\n * let ret_3: i32 = obj.top();\n * let ret_4: bool = obj.empty();\n */"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class MyStack {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function top() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function empty() {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * $obj = MyStack();\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $ret_3 = $obj->top();\n * $ret_4 = $obj->empty();\n */"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "class MyStack {\n    constructor() {\n\n    }\n\n    push(x: number): void {\n\n    }\n\n    pop(): number {\n\n    }\n\n    top(): number {\n\n    }\n\n    empty(): boolean {\n\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * var obj = new MyStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define my-stack%\n  (class object%\n    (super-new)\n    (init-field)\n    \n    ; push : exact-integer? -> void?\n    (define/public (push x)\n\n      )\n    ; pop : -> exact-integer?\n    (define/public (pop)\n\n      )\n    ; top : -> exact-integer?\n    (define/public (top)\n\n      )\n    ; empty : -> boolean?\n    (define/public (empty)\n\n      )))\n\n;; Your my-stack% object will be instantiated and called as such:\n;; (define obj (new my-stack%))\n;; (send obj push x)\n;; (define param_2 (send obj pop))\n;; (define param_3 (send obj top))\n;; (define param_4 (send obj empty))"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec my_stack_init_() -> any().\nmy_stack_init_() ->\n  .\n\n-spec my_stack_push(X :: integer()) -> any().\nmy_stack_push(X) ->\n  .\n\n-spec my_stack_pop() -> integer().\nmy_stack_pop() ->\n  .\n\n-spec my_stack_top() -> integer().\nmy_stack_top() ->\n  .\n\n-spec my_stack_empty() -> boolean().\nmy_stack_empty() ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_stack_init_(),\n%% my_stack_push(X),\n%% Param_2 = my_stack_pop(),\n%% Param_3 = my_stack_top(),\n%% Param_4 = my_stack_empty(),\n\n%% my_stack_init_ will be called before every test case, in which you can do some necessary initializations."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule MyStack do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec push(x :: integer) :: any\n  def push(x) do\n\n  end\n\n  @spec pop() :: integer\n  def pop() do\n\n  end\n\n  @spec top() :: integer\n  def top() do\n\n  end\n\n  @spec empty() :: boolean\n  def empty() do\n\n  end\nend\n\n# Your functions will be called as such:\n# MyStack.init_()\n# MyStack.push(x)\n# param_2 = MyStack.pop()\n# param_3 = MyStack.top()\n# param_4 = MyStack.empty()\n\n# MyStack.init_ will be called before every test case, in which you can do some necessary initializations."
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class MyStack {\n\n  MyStack() {\n\n  }\n  \n  void push(int x) {\n\n  }\n  \n  int pop() {\n\n  }\n  \n  int top() {\n\n  }\n  \n  bool empty() {\n\n  }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = MyStack();\n * obj.push(x);\n * int param2 = obj.pop();\n * int param3 = obj.top();\n * bool param4 = obj.empty();\n */"
            }
        ],
        "testcase": "[\"MyStack\",\"push\",\"push\",\"top\",\"pop\",\"empty\"]\n[[],[1],[2],[],[],[]]",
        "testable": true,
        "templateMeta": {
            "classname": "MyStack",
            "constructor": {
                "params": []
            },
            "methods": [
                {
                    "params": [
                        {
                            "type": "integer",
                            "name": "x"
                        }
                    ],
                    "name": "push",
                    "return": {
                        "type": "void"
                    }
                },
                {
                    "params": [],
                    "return": {
                        "type": "integer"
                    },
                    "name": "pop"
                },
                {
                    "params": [],
                    "name": "top",
                    "return": {
                        "type": "integer"
                    }
                },
                {
                    "params": [],
                    "name": "empty",
                    "return": {
                        "type": "boolean"
                    }
                }
            ],
            "return": {
                "type": "boolean"
            },
            "systemdesign": true
        }
    },
    {
        "id": 216,
        "fid": 216,
        "name": "Combination Sum III",
        "slug": "combination-sum-iii",
        "link": "https://leetcode.com/problems/combination-sum-iii/description/",
        "percent": 67.44619107319768,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "array",
            "backtracking"
        ],
        "totalAC": "384.7K",
        "totalSubmit": "570.3K",
        "likes": 4651,
        "dislikes": 95,
        "desc": "<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>\n\n<ul>\n\t<li>Only numbers <code>1</code> through <code>9</code> are used.</li>\n\t<li>Each number is used <strong>at most once</strong>.</li>\n</ul>\n\n<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 7\n<strong>Output:</strong> [[1,2,4]]\n<strong>Explanation:</strong>\n1 + 2 + 4 = 7\nThere are no other valid combinations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 9\n<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]\n<strong>Explanation:</strong>\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 4, n = 1\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<vector<int>> combinationSum3(int k, int n) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def combinationSum3(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public IList<IList<int>> CombinationSum3(int k, int n) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number} k\n * @param {number} n\n * @return {number[][]}\n */\nvar combinationSum3 = function(k, n) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer} k\n# @param {Integer} n\n# @return {Integer[][]}\ndef combination_sum3(k, n)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func combinationSum3(_ k: Int, _ n: Int) -> [[Int]] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func combinationSum3(k int, n int) [][]int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def combinationSum3(k: Int, n: Int): List[List[Int]] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun combinationSum3(k: Int, n: Int): List<List<Int>> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn combination_sum3(k: i32, n: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $k\n     * @param Integer $n\n     * @return Integer[][]\n     */\n    function combinationSum3($k, $n) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function combinationSum3(k: number, n: number): number[][] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (combination-sum3 k n)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec combination_sum3(K :: integer(), N :: integer()) -> [[integer()]].\ncombination_sum3(K, N) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec combination_sum3(k :: integer, n :: integer) :: [[integer]]\n  def combination_sum3(k, n) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<List<int>> combinationSum3(int k, int n) {\n\n  }\n}"
            }
        ],
        "testcase": "3\n7",
        "testable": true,
        "templateMeta": {
            "name": "combinationSum3",
            "params": [
                {
                    "name": "k",
                    "type": "integer"
                },
                {
                    "name": "n",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "list<list<integer>>",
                "dealloc": true
            }
        }
    },
    {
        "id": 1013,
        "fid": 509,
        "name": "Fibonacci Number",
        "slug": "fibonacci-number",
        "link": "https://leetcode.com/problems/fibonacci-number/description/",
        "percent": 69.55885998514896,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "array"
        ],
        "totalAC": "1.2M",
        "totalSubmit": "1.7M",
        "likes": 6078,
        "dislikes": 304,
        "desc": "<p>The <b>Fibonacci numbers</b>, commonly denoted <code>F(n)</code> form a sequence, called the <b>Fibonacci sequence</b>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>\n\n<pre>\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n &gt; 1.\n</pre>\n\n<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 30</code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int fib(int n) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int fib(int n) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def fib(self, n: int) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "\n\nint fib(int n){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int Fib(int n) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar fib = function(n) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer} n\n# @return {Integer}\ndef fib(n)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func fib(_ n: Int) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func fib(n int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def fib(n: Int): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun fib(n: Int): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn fib(n: i32) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function fib($n) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function fib(n: number): number {\n\n};"
            }
        ],
        "testcase": "2",
        "testable": true,
        "templateMeta": {
            "name": "fib",
            "params": [
                {
                    "name": "n",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 209,
        "fid": 209,
        "name": "Minimum Size Subarray Sum",
        "slug": "minimum-size-subarray-sum",
        "link": "https://leetcode.com/problems/minimum-size-subarray-sum/description/",
        "percent": 44.77397361689294,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "facebook"
        ],
        "tags": [
            "array",
            "two-pointers",
            "binary-search"
        ],
        "totalAC": "656.2K",
        "totalSubmit": "1.5M",
        "likes": 8648,
        "dislikes": 239,
        "desc": "<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a </em><span data-keyword=\"subarray-nonempty\"><em>subarray</em></span><em> whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 4, nums = [1,4,4]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>.",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def minSubArrayLen(self, target, nums):\n        \"\"\"\n        :type target: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int minSubArrayLen(int target, int* nums, int numsSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int MinSubArrayLen(int target, int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\nvar minSubArrayLen = function(target, nums) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer} target\n# @param {Integer[]} nums\n# @return {Integer}\ndef min_sub_array_len(target, nums)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func minSubArrayLen(_ target: Int, _ nums: [Int]) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func minSubArrayLen(target int, nums []int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def minSubArrayLen(target: Int, nums: Array[Int]): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun minSubArrayLen(target: Int, nums: IntArray): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn min_sub_array_len(target: i32, nums: Vec<i32>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $target\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minSubArrayLen($target, $nums) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function minSubArrayLen(target: number, nums: number[]): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (min-sub-array-len target nums)\n  (-> exact-integer? (listof exact-integer?) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec min_sub_array_len(Target :: integer(), Nums :: [integer()]) -> integer().\nmin_sub_array_len(Target, Nums) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec min_sub_array_len(target :: integer, nums :: [integer]) :: integer\n  def min_sub_array_len(target, nums) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int minSubArrayLen(int target, List<int> nums) {\n\n  }\n}"
            }
        ],
        "testcase": "7\n[2,3,1,2,4,3]",
        "testable": true,
        "templateMeta": {
            "name": "minSubArrayLen",
            "params": [
                {
                    "name": "target",
                    "type": "integer"
                },
                {
                    "name": "nums",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 19,
        "fid": 19,
        "name": "Remove Nth Node From End of List",
        "slug": "remove-nth-node-from-end-of-list",
        "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/",
        "percent": 40.566850680241956,
        "level": "Medium",
        "category": "algorithms",
        "tags": [
            "linked-list",
            "two-pointers"
        ],
        "totalAC": "1.9M",
        "totalSubmit": "4.6M",
        "likes": 14579,
        "dislikes": 604,
        "desc": "<p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], n = 2\n<strong>Output:</strong> [1,2,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1], n = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2], n = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>sz</code>.</li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do this in one pass?</p>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} n\n# @return {ListNode}\ndef remove_nth_from_end(head, n)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $n\n     * @return ListNode\n     */\n    function removeNthFromEnd($head, $n) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (remove-nth-from-end head n)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec remove_nth_from_end(Head :: #list_node{} | null, N :: integer()) -> #list_node{} | null.\nremove_nth_from_end(Head, N) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec remove_nth_from_end(head :: ListNode.t | nil, n :: integer) :: ListNode.t | nil\n  def remove_nth_from_end(head, n) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? removeNthFromEnd(ListNode? head, int n) {\n\n  }\n}"
            }
        ],
        "testcase": "[1,2,3,4,5]\n2",
        "testable": true,
        "templateMeta": {
            "name": "removeNthFromEnd",
            "params": [
                {
                    "name": "head",
                    "type": "ListNode",
                    "dealloc": false
                },
                {
                    "name": "n",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "ListNode",
                "dealloc": true
            }
        }
    },
    {
        "id": 235,
        "fid": 235,
        "name": "Lowest Common Ancestor of a Binary Search Tree",
        "slug": "lowest-common-ancestor-of-a-binary-search-tree",
        "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/",
        "percent": 60.97391915275339,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "amazon",
            "facebook",
            "microsoft",
            "twitter"
        ],
        "tags": [
            "tree"
        ],
        "totalAC": "1.1M",
        "totalSubmit": "1.8M",
        "likes": 8748,
        "dislikes": 248,
        "desc": "<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [2,1], p = 2, q = 1\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the BST.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    \n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\n\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @param {TreeNode} p\n# @param {TreeNode} q\n# @return {TreeNode}\ndef lowest_common_ancestor(root, p, q)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\n\nclass Solution {\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val   int\n *     Left  *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\t\n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\n\nobject Solution {\n    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int = 0) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\n\nclass Solution {\n    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\n\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return TreeNode\n     */\n    function lowestCommonAncestor($root, $p, $q) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n\t\n};"
            }
        ],
        "testcase": "[6,2,8,0,4,7,9,null,null,3,5]\n2\n8",
        "testable": true,
        "templateMeta": {
            "name": "lowestCommonAncestor",
            "params": [
                {
                    "name": "root",
                    "type": "TreeNode"
                },
                {
                    "name": "p",
                    "type": "integer"
                },
                {
                    "name": "q",
                    "type": "integer"
                }
            ],
            "return": {
                "type": "TreeNode"
            },
            "manual": true
        }
    },
    {
        "id": 344,
        "fid": 344,
        "name": "Reverse String",
        "slug": "reverse-string",
        "link": "https://leetcode.com/problems/reverse-string/description/",
        "percent": 76.50975003149688,
        "level": "Easy",
        "category": "algorithms",
        "tags": [
            "two-pointers",
            "string"
        ],
        "totalAC": "2M",
        "totalSubmit": "2.6M",
        "likes": 6819,
        "dislikes": 1042,
        "desc": "<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>\n\n<p>You must do this by modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> with <code>O(1)</code> extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n<strong>Output:</strong> [\"o\",\"l\",\"l\",\"e\",\"h\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n<strong>Output:</strong> [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is a <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\">printable ascii character</a>.</li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public void reverseString(char[] s) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "void reverseString(char* s, int sSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public void ReverseString(char[] s) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nvar reverseString = function(s) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Character[]} s\n# @return {Void} Do not return anything, modify s in-place instead.\ndef reverse_string(s)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func reverseString(_ s: inout [Character]) {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func reverseString(s []byte)  {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def reverseString(s: Array[Char]): Unit = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun reverseString(s: CharArray): Unit {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn reverse_string(s: &mut Vec<char>) {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param String[] $s\n     * @return NULL\n     */\n    function reverseString(&$s) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "/**\n Do not return anything, modify s in-place instead.\n */\nfunction reverseString(s: string[]): void {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (reverse-string s)\n  (-> (listof char?) void?)\n\n  )"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  void reverseString(List<String> s) {\n\n  }\n}"
            }
        ],
        "testcase": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
        "testable": true,
        "templateMeta": {
            "name": "reverseString",
            "params": [
                {
                    "name": "s",
                    "type": "character[]"
                }
            ],
            "return": {
                "type": "void"
            },
            "output": {
                "paramindex": 0
            }
        }
    },
    {
        "id": 253,
        "fid": 253,
        "name": "Meeting Rooms II",
        "slug": "meeting-rooms-ii",
        "link": "https://leetcode.com/problems/meeting-rooms-ii/description/",
        "percent": 50.528473807139584,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "facebook",
            "google",
            "snapchat"
        ],
        "tags": [
            "heap",
            "greedy",
            "sort"
        ],
        "totalAC": "757.4K",
        "totalSubmit": "1.5M",
        "likes": 6339,
        "dislikes": 136,
        "desc": "<p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return <em>the minimum number of conference rooms required</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> intervals = [[0,30],[5,10],[15,20]]\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> intervals = [[7,10],[2,4]]\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    int minMeetingRooms(vector<vector<int>>& intervals) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def minMeetingRooms(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "int minMeetingRooms(int** intervals, int intervalsSize, int* intervalsColSize){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public int MinMeetingRooms(int[][] intervals) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar minMeetingRooms = function(intervals) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[][]} intervals\n# @return {Integer}\ndef min_meeting_rooms(intervals)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func minMeetingRooms(_ intervals: [[Int]]) -> Int {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func minMeetingRooms(intervals [][]int) int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def minMeetingRooms(intervals: Array[Array[Int]]): Int = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun minMeetingRooms(intervals: Array<IntArray>): Int {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn min_meeting_rooms(intervals: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[][] $intervals\n     * @return Integer\n     */\n    function minMeetingRooms($intervals) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function minMeetingRooms(intervals: number[][]): number {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (min-meeting-rooms intervals)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec min_meeting_rooms(Intervals :: [[integer()]]) -> integer().\nmin_meeting_rooms(Intervals) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec min_meeting_rooms(intervals :: [[integer]]) :: integer\n  def min_meeting_rooms(intervals) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  int minMeetingRooms(List<List<int>> intervals) {\n\n  }\n}"
            }
        ],
        "testcase": "[[0,30],[5,10],[15,20]]",
        "testable": true,
        "templateMeta": {
            "name": "minMeetingRooms",
            "params": [
                {
                    "name": "intervals",
                    "type": "integer[][]"
                }
            ],
            "return": {
                "type": "integer"
            }
        }
    },
    {
        "id": 15,
        "fid": 15,
        "name": "3Sum",
        "slug": "3sum",
        "link": "https://leetcode.com/problems/3sum/description/",
        "percent": 32.42263976923572,
        "level": "Medium",
        "category": "algorithms",
        "companies": [
            "adobe",
            "amazon",
            "bloomberg",
            "facebook",
            "microsoft"
        ],
        "tags": [
            "array",
            "two-pointers"
        ],
        "totalAC": "2.5M",
        "totalSubmit": "7.7M",
        "likes": 23822,
        "dislikes": 2171,
        "desc": "<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>\n\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,1,2,-1,-4]\n<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]\n<strong>Explanation:</strong> \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,1]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The only possible triplet does not sum up to 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0]\n<strong>Output:</strong> [[0,0,0]]\n<strong>Explanation:</strong> The only possible triplet sums up to 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "templates": [
            {
                "value": "cpp",
                "text": "C++",
                "defaultCode": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n    }\n};"
            },
            {
                "value": "java",
                "text": "Java",
                "defaultCode": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "python",
                "text": "Python",
                "defaultCode": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
            },
            {
                "value": "python3",
                "text": "Python3",
                "defaultCode": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        "
            },
            {
                "value": "c",
                "text": "C",
                "defaultCode": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n\n}"
            },
            {
                "value": "csharp",
                "text": "C#",
                "defaultCode": "public class Solution {\n    public IList<IList<int>> ThreeSum(int[] nums) {\n        \n    }\n}"
            },
            {
                "value": "javascript",
                "text": "JavaScript",
                "defaultCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function(nums) {\n    \n};"
            },
            {
                "value": "ruby",
                "text": "Ruby",
                "defaultCode": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef three_sum(nums)\n    \nend"
            },
            {
                "value": "swift",
                "text": "Swift",
                "defaultCode": "class Solution {\n    func threeSum(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}"
            },
            {
                "value": "golang",
                "text": "Go",
                "defaultCode": "func threeSum(nums []int) [][]int {\n    \n}"
            },
            {
                "value": "scala",
                "text": "Scala",
                "defaultCode": "object Solution {\n    def threeSum(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}"
            },
            {
                "value": "kotlin",
                "text": "Kotlin",
                "defaultCode": "class Solution {\n    fun threeSum(nums: IntArray): List<List<Int>> {\n        \n    }\n}"
            },
            {
                "value": "rust",
                "text": "Rust",
                "defaultCode": "impl Solution {\n    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"
            },
            {
                "value": "php",
                "text": "PHP",
                "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function threeSum($nums) {\n        \n    }\n}"
            },
            {
                "value": "typescript",
                "text": "TypeScript",
                "defaultCode": "function threeSum(nums: number[]): number[][] {\n\n};"
            },
            {
                "value": "racket",
                "text": "Racket",
                "defaultCode": "(define/contract (three-sum nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n\n  )"
            },
            {
                "value": "erlang",
                "text": "Erlang",
                "defaultCode": "-spec three_sum(Nums :: [integer()]) -> [[integer()]].\nthree_sum(Nums) ->\n  ."
            },
            {
                "value": "elixir",
                "text": "Elixir",
                "defaultCode": "defmodule Solution do\n  @spec three_sum(nums :: [integer]) :: [[integer]]\n  def three_sum(nums) do\n\n  end\nend"
            },
            {
                "value": "dart",
                "text": "Dart",
                "defaultCode": "class Solution {\n  List<List<int>> threeSum(List<int> nums) {\n\n  }\n}"
            }
        ],
        "testcase": "[-1,0,1,2,-1,-4]",
        "testable": true,
        "templateMeta": {
            "name": "threeSum",
            "params": [
                {
                    "name": "nums",
                    "type": "integer[]"
                }
            ],
            "return": {
                "type": "list<list<integer>>",
                "colsize": 3,
                "dealloc": true
            }
        }
    }
]